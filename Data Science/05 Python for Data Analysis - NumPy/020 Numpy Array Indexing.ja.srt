1
00:00:06,480 --> 00:00:11,210
皆さんこんにちは、この講演では、キスとセレクションの講義でパイにようこそ。

2
00:00:11,230 --> 00:00:15,040
パイから要素またはグループ要素を選択する方法について説明します。

3
00:00:15,060 --> 00:00:19,260
さあ始めて、Juberノートブックにジャンプして始めましょう。

4
00:00:19,260 --> 00:00:19,760
大丈夫。

5
00:00:19,800 --> 00:00:21,360
あなたは木星のノートブックにいます。

6
00:00:21,360 --> 00:00:23,880
私はすでに重要な審判とPを言った。 私が始めるのは、サンプル配列を作成することです。変数A

7
00:00:24,040 --> 00:00:29,010
R Rが終わりpと等しいと言うつもりです。

8
00:00:29,040 --> 00:00:31,370
範囲を得ました。

9
00:00:31,500 --> 00:00:33,050
&nbsp;

10
00:00:33,130 --> 00:00:41,700
ちょうどタブを使用してそこにオートコンプリートして、私は0から10に行きます.10から10と言うとき、私はその出力を得るために実際の出力を意味します。

11
00:00:41,700 --> 00:00:45,570
だから私は0から10まで11要素の配列を持っています。

12
00:00:45,870 --> 00:00:50,760
&nbsp;

13
00:00:50,760 --> 00:00:57,330
配列の要素の1つまたはいくつかを選択する最も簡単な方法は、Pythonリストからのインデックス作成のように見えます。

14
00:00:57,330 --> 00:00:58,110
基本的に、これを行うには角括弧と表記法を使用します。

15
00:00:58,140 --> 00:01:03,060
先に進むと、配列自体の変数名をタイプします。

16
00:01:03,140 --> 00:01:07,500
大括弧を通して、数字を渡すだけでできるインデックスで単一の値を取得します。

17
00:01:07,600 --> 00:01:13,530
意味私はインデックス8で値をしたい場合は私は8を渡すことができますし、私はこの場合はx

18
00:01:14,010 --> 00:01:21,000
8の値を返すでしょう。

19
00:01:21,000 --> 00:01:21,470
&nbsp;

20
00:01:21,540 --> 00:01:27,030
Pythonのリストのように範囲内の値を取得したい場合は、この配列を作成するようにアレンジされているので、実際は8です。

21
00:01:27,030 --> 00:01:29,330
スライス表記を使用すると、開始インデックスと終了インデックスを指定できます。

22
00:01:29,340 --> 00:01:37,010
だから私が先に進んでコロンブス5と言うと、インデックス1が1で始まり、インデックス5が4であるインデックス5に至るまで、インデックス作成がゼロから始まるからです。

23
00:01:37,080 --> 00:01:43,650
&nbsp;

24
00:01:43,650 --> 00:01:49,470
&nbsp;

25
00:01:49,500 --> 00:01:57,990
だから私はコロン5をゼロと言うことができ、それはインデックス5のすべての方法で0からのすべての値を返すこれの別の例を示すために。

26
00:01:57,990 --> 00:02:00,710
&nbsp;

27
00:02:00,750 --> 00:02:06,840
ストップポイントまたは開始ポイントを削除して先に進め、配列内のすべてのものが必要であることを示すこともできます。

28
00:02:06,900 --> 00:02:07,890
右手の始めからすべて。

29
00:02:07,950 --> 00:02:10,190
&nbsp;

30
00:02:10,200 --> 00:02:17,710
たとえば、開始パラメータを0と指定する代わりにすべてをインデックス6にする場合は、コロンを入れてから、6のインデックスに配列の先頭まで6

31
00:02:17,790 --> 00:02:24,210
Elloraのすべてを入れてください。

32
00:02:24,270 --> 00:02:24,860
&nbsp;

33
00:02:24,870 --> 00:02:30,870
だからコロン6をゼロと言うのと同じことですが、石炭自体を入れるだけでタイピングを少しは省くことができます。

34
00:02:30,870 --> 00:02:32,990
&nbsp;

35
00:02:32,990 --> 00:02:43,060
同様に私が先に進むことができるのは、特定のインデックスから開始し、配列の最後まですべてを取得したい場合に配列を指定することです。これは、石炭のスライス表記を使用してPythonリストで行ったのと同じステーションを使用できます。

36
00:02:43,080 --> 00:02:50,340
&nbsp;

37
00:02:50,700 --> 00:02:51,940
&nbsp;

38
00:02:52,170 --> 00:02:56,910
この数字の表記法を使用しているときにコロンを使用すると、実際にインデックス5以降を把握していないことに注意してください。

39
00:02:56,910 --> 00:02:59,410
&nbsp;

40
00:02:59,490 --> 00:03:05,670
Pythonの表記法までの索引付けを覚えておくことはゼロから始まるので、索引5上のすべてを取得しています。

41
00:03:05,670 --> 00:03:06,780
&nbsp;

42
00:03:06,780 --> 00:03:15,210
したがって、ここ5は実際にインデックス6であり、この5つのコロンの表記では、インデックス5を超えるすべてをスクラップすると言います。

43
00:03:15,210 --> 00:03:15,600
覚えているインデックス5が実際にここに4であるので、それは5 6 7 8 9 9になるでしょう。

44
00:03:15,600 --> 00:03:21,200
インデックス作成はゼロから始まるので、5つの要素を取得しました。

45
00:03:21,750 --> 00:03:25,700
&nbsp;

46
00:03:25,830 --> 00:03:32,730
意味は、もし私が5つのコロンを言うなら、それは4で起こる5つ目のインデックスを越える全てをつかみ、このコロンについてのより詳しい情報が必要ならば、Pythonのリストスライス表記を見直すことができます。

47
00:03:32,730 --> 00:03:38,480
しかし、本質的にこれは、通常のPythonリストの場合とまったく同じです。

48
00:03:38,550 --> 00:03:42,890
放送する能力があるため、配列は通常のPythonリストとは異なります。

49
00:03:43,300 --> 00:03:49,310
私は先に進み、これの例を示します。

50
00:03:49,350 --> 00:03:51,710
私は配列を取って要素をつかむつもりです。

51
00:03:51,810 --> 00:03:56,390
ゼロと5。

52
00:03:56,440 --> 00:03:58,060
だから、それはゼロ1 2 3 4になるだろうし、それは100と等しいと考えています。

53
00:03:58,110 --> 00:04:04,080
そしてそれが何をするのか。

54
00:04:04,140 --> 00:04:05,560
その値を最初の5桁にブロードキャストして、すべて100にする予定です。

55
00:04:05,820 --> 00:04:12,830
&nbsp;

56
00:04:12,960 --> 00:04:21,510
私は先に進んで配列をリセットして、配列を表示すると、ちょうど1秒後に0まで戻ってきます。

57
00:04:21,510 --> 00:04:24,350
私はあなたにそれのスライスやレートに重要なノーを見せたくありません。

58
00:04:24,600 --> 00:04:28,420
私が先に進んで、アンダースコアのスコアの下のスライスという変数を作成するのはArrayの場合です。

59
00:04:28,440 --> 00:04:36,490
&nbsp;

60
00:04:36,500 --> 00:04:46,360
そして、私は配列のスライスと等しいと言いました。ここでは、配列のスライスには配列があり、そこには1つ2つ3つ4つの5つがあります。

61
00:04:46,380 --> 00:04:48,590
基本的に配列の半分の最初のチャンク。

62
00:04:48,600 --> 00:04:51,960
私がSaray weenieで放送する場合、私はアレイのスライスを言うが、私は結腸を使う。

63
00:04:52,200 --> 00:04:59,580
つまり、私はそのスライスのすべてをつかんでいます。

64
00:04:59,580 --> 00:05:02,550
私は99のような別の番号にこれを放送しようとします。

65
00:05:02,570 --> 00:05:06,820
つまり、配列のスライスをチェックすると、99の束が表示されます。

66
00:05:06,900 --> 00:05:11,780
ここで注意深く注意を払う必要があります。

67
00:05:12,000 --> 00:05:14,480
配列を呼び出すと、実際にはスライスだけでなく元の配列にも変化します99。

68
00:05:14,520 --> 00:05:21,800
私は2つを呼び出しました。

69
00:05:21,810 --> 00:05:22,960
したがって、元の配列でもその変更がどのように行われてデータがコピーされないのかを知っておく必要があります。

70
00:05:23,190 --> 00:05:28,950
それはただの見解です。

71
00:05:29,130 --> 00:05:30,560
元の配列。

72
00:05:30,710 --> 00:05:32,100
&nbsp;

73
00:05:32,280 --> 00:05:38,250
その理由は、非常に大きな配列を持つメモリの問題を避けるためであり、piが配列のコピーを自動的に設定しないことを意味します。

74
00:05:38,250 --> 00:05:41,140
&nbsp;

75
00:05:41,380 --> 00:05:47,940
実際にコピーが必要な場合は、元の配列への参照ではなく、実際には特にcopyを指定します。

76
00:05:47,940 --> 00:05:49,410
だから私はこのようなことをすることができます。

77
00:05:49,530 --> 00:05:51,480
&nbsp;

78
00:05:51,720 --> 00:06:01,620
私は先に進み、rはコピーを強調し、配列のコピーメソッドを使用して、コピーが必要であることを具体的に示すことができます。

79
00:06:01,620 --> 00:06:03,320
だから私の配列を見れば、9 9 9 9 9 x cetera、次に6 7 8 9 10です。

80
00:06:03,450 --> 00:06:09,410
配列のコピーを見ると、同じことになります。

81
00:06:09,780 --> 00:06:14,320
しかし、もし私が配列コピーを変更したら、すべての値を100にして放送することもできます。

82
00:06:14,500 --> 00:06:20,550
そして、私は配列のコピーが100であることをチェックアウトします。

83
00:06:20,940 --> 00:06:25,420
しかし、元の配列はまだ100へのコマンドでその放送に影響されません。

84
00:06:25,440 --> 00:06:32,190
それについてのノートを見直してください。

85
00:06:32,190 --> 00:06:34,070
&nbsp;

86
00:06:34,120 --> 00:06:40,360
&nbsp;

87
00:06:40,360 --> 00:06:47,370
&nbsp;

88
00:06:47,380 --> 00:06:53,340
これは少し混乱しますが、ここでの基本的な前提は、実際に配列のスライスをつかみ、配列のコピーが必要だと明示的に言わずに変数として設定すると、元の配列へのリンクを表示し、その変更が元の配列に実際に影響します。

89
00:06:53,340 --> 00:06:56,760
OK。

90
00:06:56,760 --> 00:06:57,400
配列へのインデックス付けについて説明しましょう。

91
00:06:57,690 --> 00:07:00,550
そうでなければ行列として知られています。

92
00:07:00,690 --> 00:07:02,810
私は先に進んで、ここですべての細胞を1秒間クリアします。

93
00:07:02,880 --> 00:07:07,920
ここですべてのセルをクリアしたところ、私たちは先に進んでa to d配列を作成します。

94
00:07:07,960 --> 00:07:15,180
私はNと言うつもりです。 P。 配列と私は入れ子リストを渡すつもりです。

95
00:07:17,520 --> 00:07:24,020
だから私は5 10 15 20 25 30、そして最後には35 40 45と言うつもりです。

96
00:07:24,930 --> 00:07:37,830
だから私は外に出て行きたいと思っています。ここに私は三つの列を持っています。

97
00:07:38,430 --> 00:07:44,280
&nbsp;

98
00:07:44,280 --> 00:07:46,010
すばらしいです。

99
00:07:46,050 --> 00:07:46,820
大丈夫。

100
00:07:46,830 --> 00:07:47,430
aから配列またはMatrixに要素を取り込むための一般的なフォーマットは2つあります。

101
00:07:47,430 --> 00:07:52,880
それのための二重のブラケットがあります。

102
00:07:52,880 --> 00:07:54,500
そして、コンマの付いた単一の括弧formitがあります。

103
00:07:54,570 --> 00:07:57,270
&nbsp;

104
00:07:57,270 --> 00:08:01,570
二重括弧形式を示してみましょう。次に、使用することをお勧めする形式である一括弧形式の例を示しますが、あなたが野生で遭遇した場合に備えて、両方を知っておく必要があります。

105
00:08:01,560 --> 00:08:07,200
&nbsp;

106
00:08:07,200 --> 00:08:08,750
もう一度私の2つの理論があります。

107
00:08:08,760 --> 00:08:10,970
&nbsp;

108
00:08:11,120 --> 00:08:18,390
&nbsp;

109
00:08:18,390 --> 00:08:27,910
さて、私は数字5をつかみたいとしましょう。最初の列またはインデックス0の行にあり、最初の列のインデックスは0で、大括弧表記の場合は最初に必要な行をパーザーしてから、次に必要な列をパーザーできます。

110
00:08:27,900 --> 00:08:28,700
ここで00を渡すと数字5が返されます。

111
00:08:28,770 --> 00:08:32,070
これは、最初の列の最初の行の要素です。

112
00:08:32,230 --> 00:08:36,410
私ができることは、削除とブラケットの単一のセットを行い、Roback全体のインデックスを作成することです。

113
00:08:36,420 --> 00:08:44,640
したがって、これはインデックス0の行全体を5

114
00:08:44,670 --> 00:08:55,320
10 15という意味でインデックスし、要素25を言いたい場合は、そのインデックスの行のインデックス1を列にします。

115
00:08:55,350 --> 00:09:03,000
だから私は1 1と言うことができ、これはすべて25を返します。

116
00:09:03,000 --> 00:09:06,080
&nbsp;

117
00:09:06,100 --> 00:09:11,980
私があなたにしたいのは、ビデオを一時停止し、この二重括弧表記を使用して配列から要素を個別に取得できるかどうかを調べることです。

118
00:09:11,970 --> 00:09:15,620
大丈夫。

119
00:09:15,660 --> 00:09:15,910
最後の例として40をつかみたいとしましょう。

120
00:09:15,930 --> 00:09:19,710
それも行インデックスです。

121
00:09:19,950 --> 00:09:22,700
それは次の1つの列です。

122
00:09:23,310 --> 00:09:25,290
だからそれは40です。

123
00:09:25,680 --> 00:09:27,010
これは二重括弧の表記です。

124
00:09:27,120 --> 00:09:29,520
あなたはすべきです。

125
00:09:29,520 --> 00:09:30,380
しかし、私はカンマ単一の表記法を使用していることをお勧めします。

126
00:09:30,380 --> 00:09:36,390
&nbsp;

127
00:09:36,390 --> 00:09:42,630
そして、基本的には、大括弧の二重セットをコンマで置き換え、行のカンマカラム番号を渡します。

128
00:09:42,630 --> 00:09:45,790
&nbsp;

129
00:09:45,780 --> 00:09:54,440
たとえば、インデックス1に渡す数字30を3行目に渡したいから、インデックス1に渡す数字30が欲しいとしましょう。

130
00:09:54,930 --> 00:09:56,300
だから0 1 2それは列のインデックスにあり、それは私に30を与えます。

131
00:09:56,320 --> 00:10:03,010
&nbsp;

132
00:10:03,210 --> 00:10:11,040
&nbsp;

133
00:10:11,050 --> 00:10:17,200
そして、それはちょうど私に強調されていることを言って、二重括弧でそれをすることと同じです。私はあなたが常に共通の表記法のこの一括弧を使用することをお勧めします。

134
00:10:17,200 --> 00:10:19,990
さて、あなたは単一の要素を望んでいないが、実際の部分は望んでいないと想像してみましょう。

135
00:10:19,990 --> 00:10:24,730
&nbsp;

136
00:10:24,900 --> 00:10:31,870
たとえば、この行列からいくつかの行列が必要な場合は、スライス表記Nuritにコロンを使用して配列全体の特定のセクションを取得し、単一の要素だけを並べ替えることができます。

137
00:10:31,870 --> 00:10:36,620
私は先に進んで、あなたにそれを行う方法を示します。

138
00:10:36,820 --> 00:10:38,730
この2番目のセルを削除し、いくつかの例を示します。

139
00:10:38,770 --> 00:10:44,230
右上隅から取得したいとしましょう。

140
00:10:44,400 --> 00:10:47,640
意味私は10

141
00:10:47,760 --> 00:10:54,160
15と25 30を言いたいので、ここの右上隅はこれを行うために私が先に進むことができるスライス表記法です。

142
00:10:54,150 --> 00:10:59,860
だから私は行を呼び出すためにすべてをつかんで1列目以降をつかんで10

143
00:11:00,040 --> 00:11:12,390
15 25 30を返すと言うことができます。

144
00:11:12,390 --> 00:11:14,890
私を入れてもう一度これを打ち破ろう。

145
00:11:14,880 --> 00:11:16,920
私たちが言っていることは、行0と行1をコロンとして含めずにすべてを取得することです。

146
00:11:17,130 --> 00:11:24,880
しかし、2つを含めないでください。

147
00:11:25,140 --> 00:11:26,520
&nbsp;

148
00:11:26,560 --> 00:11:33,790
私もそれをスライスしていると私は先に進んで、それは単なるコマンドだと私はコロンのことをこれらの2行の行0と行1を返すと言うので、私は列は1列目から最後まですべてを取得します。基本的には、この列0のすべてをドロップし、これらの2つの小さなサブセクション10

149
00:11:33,870 --> 00:11:43,300
15と25

150
00:11:43,300 --> 00:11:49,590
30を返します。

151
00:11:49,840 --> 00:11:59,520
大丈夫。

152
00:11:59,520 --> 00:12:00,730
45）で、スライム表記法を使用して、Sarayのサブセクションを取得するために、この単一のブラケットカンマインデックス表記をpiで使用できるかどうかを確認することです。

153
00:12:00,730 --> 00:12:08,280
私が今お勧めするのは、あなたの心をつかむためのサブセクション（例えば、20 25

154
00:12:08,290 --> 00:12:15,700
30と35 40

155
00:12:15,970 --> 00:12:18,790
&nbsp;

156
00:12:18,970 --> 00:12:26,920
そして、あなたがもっと大きなサブセクションをつかむことができるかどうかを確認することをお勧めします。

157
00:12:26,910 --> 00:12:29,350
&nbsp;

158
00:12:29,350 --> 00:12:34,920
&nbsp;

159
00:12:36,220 --> 00:12:41,110
この講義のノートブックはいつでもご覧になれます。この講義では、2次元アレイスライスの例をもう少し紹介します。この種の素晴らしいスライスをあまり多くはしませんので、混乱します。

160
00:12:41,110 --> 00:12:41,680
&nbsp;

161
00:12:41,670 --> 00:12:45,820
あなたはそれが実際にはコース全体で頻繁にそれを実際にしないので、あまりにも心配する必要はありません。

162
00:12:45,820 --> 00:12:46,730
さて、私は通常、単一の要素または行全体または列全体を単純に取得します。

163
00:12:47,010 --> 00:12:51,700
彼らは通常、ここで行ったようにサブセクションのサブセクションをつかむことはありません。

164
00:12:51,760 --> 00:12:56,430
大丈夫。

165
00:12:56,440 --> 00:12:57,020
&nbsp;

166
00:12:57,280 --> 00:13:02,290
次に、条件付き選択であるこのコースで、より頻繁に使用するより重要な選択方法に移りましょう。

167
00:13:02,290 --> 00:13:05,750
&nbsp;

168
00:13:05,810 --> 00:13:15,240
私は先に進んで、新しい配列を作成するつもりです。単一の言及配列sayとPidoは1つのカンマ11を配置し、この配列をチェックアウトします。

169
00:13:15,280 --> 00:13:18,180
OK。

170
00:13:18,850 --> 00:13:19,350
ですから、このアレイの場合、私は1つ2つ3つ4つ5つ6つ7つ8つ9つ10です。

171
00:13:19,360 --> 00:13:23,300
&nbsp;

172
00:13:23,740 --> 00:13:30,580
私ができることは、この配列を比較演算子と組み合わせて実際に完全なブール値配列を得ることです。

173
00:13:30,630 --> 00:13:32,240
&nbsp;

174
00:13:32,340 --> 00:13:40,450
そして、私が意味することは、これを1桁の数字と比較すると、5より大きい場合はブール値の配列が得られるということです。

175
00:13:40,450 --> 00:13:42,730
それはDタイプB O Lと言います。

176
00:13:42,730 --> 00:13:45,010
したがって、これらは真または偽の値です。

177
00:13:45,250 --> 00:13:47,110
その比較が偽りで真実であるか、比較が真実であっても、それは私に間違いを与えます。

178
00:13:47,250 --> 00:13:52,990
そして、私は先に進んで、配列を強調するかもしれないので、これを保存することができます。

179
00:13:53,160 --> 00:13:59,650
だから今ブールのアンダースコアを呼び出すと、私はこのブール値の配列を返します。

180
00:13:59,640 --> 00:14:06,270
これで実際に条件付き選択を行うことができます。

181
00:14:06,280 --> 00:14:09,850
意味は私は2つの括弧の中でそれを渡すことができ、私はこのブール配列が真実であったところで結果を得るだけです。

182
00:14:09,850 --> 00:14:12,440
&nbsp;

183
00:14:15,250 --> 00:14:19,990
&nbsp;

184
00:14:19,990 --> 00:14:26,440
もう一度その配列を取得して比較演算子を使用すると、ブール値の配列を意味するブール値の配列が返されます。

185
00:14:26,430 --> 00:14:31,020
&nbsp;

186
00:14:31,170 --> 00:14:38,200
次に、そのブール値配列を使用して、実際に起こった元の配列から要素を実際に索引付けしたり条件付きで選択したりすることができます。

187
00:14:38,200 --> 00:14:40,220
&nbsp;

188
00:14:40,230 --> 00:14:46,180
したがって、ブール値の配列が真であったインスタンスだけを返し、より一般的にはこれを2つのステップに分割します。

189
00:14:46,170 --> 00:14:47,450
あなたは実際にすべてを1つのステップで実行します。

190
00:14:47,500 --> 00:14:49,480
あなたは、5より大きいr

191
00:14:49,480 --> 00:14:54,490
rのような条件文で渡す配列の代わりに、大括弧で囲まれた括弧で囲まれ、同じ答えを返します。

192
00:14:54,950 --> 00:14:59,640
これは、条件付き選択まで常に使用される構文表記の一種です。

193
00:14:59,710 --> 00:15:04,900
例えば、3よりも小さい配列のすべての要素を知りたいとしましょう。

194
00:15:06,310 --> 00:15:12,470
&nbsp;

195
00:15:12,520 --> 00:15:20,380
&nbsp;

196
00:15:20,380 --> 00:15:25,620
私がやることは、配列の括弧を指定して3より小さい配列を宣言し、それが真であるすべての要素を返すことです。これは、このコースでたくさん使用していることです。パンダ。

197
00:15:25,970 --> 00:15:28,000
これはあなたが慣れていなければならない種類の表記です。

198
00:15:28,030 --> 00:15:30,440
&nbsp;

199
00:15:30,460 --> 00:15:37,110
私はそれ自体の内部に変数名を見るために少し奇妙なことは知っていますが、うまくいけばこれらの2つのステップに分割して、実際に何が起こっているのかを明確にします。

200
00:15:37,120 --> 00:15:40,550
&nbsp;

201
00:15:40,570 --> 00:15:45,510
ブール値の配列を渡しているだけで、元の配列のインデックスで本当の位置に戻ります。

202
00:15:45,520 --> 00:15:48,410
この講義ではそれだけです。

203
00:15:48,900 --> 00:15:50,760
&nbsp;

204
00:15:50,770 --> 00:15:58,390
私があなた自身のためにエクササイズまでやってお勧めするのは、Nと言って配列を新しいものにすることです。 P。 ドット・アー。 さて、先に進み、50と言って、これを5×10の形に作り直してください。

205
00:15:58,420 --> 00:16:01,860
いいえ、別の方法でメソッドを呼び出すだけではありません。

206
00:16:02,080 --> 00:16:08,650
これはすべて1つの配列であり、次にこの5×10の素敵な配列があります。

207
00:16:08,640 --> 00:16:10,990
したがって0〜40、次に0〜9です。

208
00:16:10,990 --> 00:16:17,530
私はあなた自身のために練習することをお勧めします。

209
00:16:17,560 --> 00:16:20,340
&nbsp;

210
00:16:20,430 --> 00:16:23,500
チャンクをつかみ、ブラケット表記を使って考えたチャンクをつかむことができるかどうかを確認してください。

211
00:16:23,500 --> 00:16:30,370
だから、あなたはあなたの13 14と23 24をつかみたいかもしれません。

212
00:16:30,370 --> 00:16:31,380
外出して、あなたがそれをやる方法を示しましょう。

213
00:16:31,380 --> 00:16:36,210
まず、2つの行と列で分割したいと思います。

214
00:16:36,390 --> 00:16:38,820
だから13時14分、行0 1と2で始まります。

215
00:16:38,980 --> 00:16:41,880
意味私は行1から2をつかみたい。

216
00:16:41,920 --> 00:16:49,730
私は先に進んで1つ言うと、この種のスライス表記法を覚えて、実際に必要なものよりも1つ多く行きます。

217
00:16:50,020 --> 00:16:52,830
&nbsp;

218
00:16:53,250 --> 00:16:59,680
だから、私は指差し3を含めずに誰かをつかむことを言っている。

219
00:16:59,670 --> 00:17:00,770
だから、これらの2つの行にする必要があります。

220
00:17:01,120 --> 00:17:05,220
行こうとすると、ここではちょうど言って、それらの行をつかむあなたのスコアであることを確認してください。

221
00:17:05,290 --> 00:17:07,310
1つの呼び出しと3つの呼び出しです。これは基本的に通常のPythonのリスト表記のように動作します。

222
00:17:07,470 --> 00:17:13,040
だから、ここでは3つまでを含むが、それ以下のインデックス1を持つ。

223
00:17:13,140 --> 00:17:18,450
14 23

224
00:17:18,450 --> 00:17:23,520
24。

225
00:17:23,560 --> 00:17:34,170
そして、列のために私はインデックスの列3つのグループで発生する13 14と23 24をしたいと私は5つのサガを含めない4つを望んでいるが、そこに5つは私たちが探していたものを返す13

226
00:17:34,170 --> 00:17:42,060
私はあなたのジュピターのノートブックで調査を設定し、次にこのマトリックスの塊をつかむことで、このことを練習することをお勧めします。

227
00:17:42,070 --> 00:17:44,310
&nbsp;

228
00:17:44,320 --> 00:17:50,600
大丈夫。

229
00:17:50,880 --> 00:17:55,050
ノートブックにはさらに多くのインデックス作成支援があります。

230
00:17:55,060 --> 00:17:55,610
&nbsp;

231
00:17:55,720 --> 00:17:58,250
PIの最終的なエクササイズにおいて、より多くのプラクティスを得るために100％快適ではないと思うならば、たくさんのことを心配しないでください。

232
00:17:58,300 --> 00:18:03,100
しかし実際にはこれはあなたにパイのできるものを知らせることです。

233
00:18:03,100 --> 00:18:05,320
私たちは、このような表記法を使用して、この種のスライス表記をしばしば行うことはしません。

234
00:18:05,560 --> 00:18:09,170
人の演算子を使用して条件付き選択を使用します。

235
00:18:09,180 --> 00:18:14,450
もっとたくさん。

236
00:18:14,580 --> 00:18:17,540
皆さんありがとうございました。次の講演でお会いしましょう。

237
00:18:17,620 --> 00:18:19,060
&nbsp;

238
00:18:19,060 --> 00:18:21,820
&nbsp;
