1
00:00:06,180 --> 00:00:11,970
みなさんこんにちはPIアレイの講義を歓迎します。この講義では、PythonとPIライブラリを使用してより高いレートを作成するさまざまな方法を学習します。

2
00:00:11,970 --> 00:00:16,690
&nbsp;

3
00:00:16,920 --> 00:00:20,460
木星のノートにジャンプして始めましょう。

4
00:00:20,490 --> 00:00:20,760
大丈夫。

5
00:00:20,760 --> 00:00:27,000
&nbsp;

6
00:00:27,030 --> 00:00:32,910
&nbsp;

7
00:00:32,910 --> 00:00:37,450
ここで私たちは木星ノートブックにあります。私たちはコース全体を通してPIライブラリを使用していますが、私は高次元ですから、本質的に1次元のベクトルまたは2次元の行列になる2つのフレーバーがあります。両方とも配列と呼ばれる。

8
00:00:37,450 --> 00:00:44,020
1つか2つがあれば、私は行きたいリストのようなPythonオブジェクトから新しいアンパイアリングを作り、リストにオブジェクトを作成する方法を示します。

9
00:00:44,020 --> 00:00:48,730
&nbsp;

10
00:00:48,980 --> 00:00:50,840
一二三。

11
00:00:51,210 --> 00:00:54,180
私が先に進み、そのリストを表示するだけであれば。

12
00:00:54,350 --> 00:00:58,450
私は1つ2つ3つを取得し、それは単なるpythonのリストです。

13
00:00:58,650 --> 00:01:06,020
私は先に進んでpをPとしてインポートすると言うでしょうし、配列を呼び出して呼び出すことができます。

14
00:01:06,290 --> 00:01:10,920
そして今、私はそのリストを配列としてキャストすることができます。

15
00:01:11,290 --> 00:01:15,900
そして、そのリストオブジェクトのコンテナとして配列を取得することに注意してください。

16
00:01:15,930 --> 00:01:20,670
そして、私は実際にこれを割り当てることができ、それから配列を呼び出すことができます。

17
00:01:20,790 --> 00:01:24,930
だから私は通常のPythonリストを配列にキャストできます。

18
00:01:24,990 --> 00:01:31,110
2次元配列または行列を取得したい場合は、1次元配列を返します。

19
00:01:31,170 --> 00:01:33,390
私はリストのリストをキャストすることができます。

20
00:01:33,420 --> 00:01:45,180
たとえば、アンダースコアの数学が3つのリストのリストと等しいと言うことができます。したがって、1つの2つの3つの4つの6つは、余分なカンマを取り除き、次に7 8

21
00:01:45,180 --> 00:01:52,450
9を取り除きます。

22
00:01:53,220 --> 00:02:03,570
&nbsp;

23
00:02:03,570 --> 00:02:09,930
&nbsp;

24
00:02:09,930 --> 00:02:14,340
だから私はリストのリストを取得して、それを配列にキャストすると、2次元配列を返します。これは、出力として表示される方法だけでなく、閉じて表示される括弧の数としても重要ですこのアレイの開口端部とを有する。

25
00:02:14,580 --> 00:02:20,640
&nbsp;

26
00:02:20,640 --> 00:02:27,260
私は2つのブラケットセットを持っています。これは、その言及可能な配列にZが3行と3列を持っていることを示しています。これは通常のPythonリストまたはリストを審判範囲にキャストする方法です。

27
00:02:27,600 --> 00:02:33,030
しかし、実際には配列を作成するために、おそらくパイの独自の組み込み生成メソッドを使用しているでしょう。

28
00:02:33,060 --> 00:02:36,090
&nbsp;

29
00:02:36,090 --> 00:02:40,520
それを行うための最も一般的な方法のいくつかを進んで行きましょう。

30
00:02:40,560 --> 00:02:46,740
最も一般的な方法はおそらくarrを使用しているより高いレートを作成することです。

31
00:02:46,740 --> 00:02:49,930
これはPythonの独自の範囲関数に実際に似ています。

32
00:02:49,950 --> 00:02:56,370
あなたは先に進み、Nと言うでしょう。 P。 整理して出発と停車を行います。

33
00:02:56,460 --> 00:03:02,490
だから、あなたが停止を開始してから、ステップサイズが3番目の引数であり、この指定された間隔内に均等に値が戻されていることに注目してください。

34
00:03:02,490 --> 00:03:04,860
&nbsp;

35
00:03:04,860 --> 00:03:14,040
だから、もし0から10までのことがPythonの範囲のように覚えていれば、インデックスはゼロから始まります。

36
00:03:14,070 --> 00:03:16,990
それは10までは含まれません。

37
00:03:17,430 --> 00:03:20,660
0からずっと9までの配列を返します。

38
00:03:20,760 --> 00:03:24,840
だから私は0で始まり、10までは含まない。

39
00:03:25,020 --> 00:03:29,480
だから私は10桁戻って0 1 2 3 4 5 6。

40
00:03:29,890 --> 00:03:33,900
基本的にPython独自の範囲関数として機能します。

41
00:03:33,960 --> 00:03:37,990
だから私はゼロからずっとZの後の10に行きたい。

42
00:03:38,190 --> 00:03:43,010
私はゼロのカンマ11と言う必要があり、それは私が戻ってくるものです。

43
00:03:43,380 --> 00:03:46,930
最後に、第3引数にステップサイズを追加することができます。

44
00:03:46,980 --> 00:03:51,820
だから私が0から10のすべての偶数であれば、ゼロと言うことができます11。

45
00:03:51,960 --> 00:03:58,930
そして、ステップサイズが2になるように、2 0 2 4 6 8 10のステップでジャンプします。

46
00:03:59,070 --> 00:04:05,580
つまり、範囲はpiを使って素早く配列を生成するための最も有用な関数の1つになります。

47
00:04:05,580 --> 00:04:06,590
&nbsp;

48
00:04:06,960 --> 00:04:12,330
特定のタイプの配列が必要な場合は、非パイロットで他の関数を使用してそのようにすることができます。

49
00:04:12,330 --> 00:04:19,970
たとえば、すべての0の配列を生成する場合は、P-docのゼロと言うことができ、1桁の数字を渡すことができます。

50
00:04:19,970 --> 00:04:22,050
&nbsp;

51
00:04:22,050 --> 00:04:30,780
ですから、1次元のベクトルを出力するか、Nと言うことができます。 P。

52
00:04:30,780 --> 00:04:36,840
最初の数字が行の数を表し、2番目の数字がそのタプルの列の数を表すことになる次元のタプルを渡して渡します。

53
00:04:36,840 --> 00:04:39,220
&nbsp;

54
00:04:39,240 --> 00:04:48,770
だから、私は3つの列で行にしたいので、3つの列に渡して、3つの列でRoseに戻ってきます。これは括弧で囲まれています。

55
00:04:48,770 --> 00:04:53,330
&nbsp;

56
00:04:53,360 --> 00:04:59,620
もし私が純粋なものを育てたいのなら、私はそれを言うことができます。

57
00:04:59,690 --> 00:05:07,580
&nbsp;

58
00:05:08,180 --> 00:05:16,370
&nbsp;

59
00:05:16,370 --> 00:05:21,500
同様に、単一の数値または1次元の配列のいずれかを渡すことができます。または2次元の行列のタプルには、レンズ空間とスペースが指定された間隔で均等に間隔を置いて返される、他の本当に便利な組み込み関数の1と0があります。

60
00:05:21,750 --> 00:05:23,960
ルワンを混乱させないことが重要です。

61
00:05:23,990 --> 00:05:31,490
配列を配列すると、範囲は基本的に開始点と終了点、および指定された刻み幅から整数を返すことがわかります。

62
00:05:31,490 --> 00:05:32,600
&nbsp;

63
00:05:32,720 --> 00:05:37,580
&nbsp;

64
00:05:37,580 --> 00:05:45,140
林の空間は実際にはポイントの数の3番目の議論を取り入れようとしています.Pゴットランドの空間と言えば、パスとスタートを止めることができます。そして、私が数値で渡すつもりの3番目の議論があります。

65
00:05:45,140 --> 00:05:50,300
&nbsp;

66
00:05:50,300 --> 00:06:00,590
だから私はゼロの開始と5の停止を持っていると私は0から5の間に均等に間隔を置いたポイントを取得したいとしましょう。

67
00:06:00,590 --> 00:06:02,510
&nbsp;

68
00:06:02,510 --> 00:06:09,650
私は3番目の引数10を渡すことができ、これは0から5までの10個の均等に離れた点の一括セットで示された一次元ベクトルを返します。

69
00:06:09,650 --> 00:06:15,490
&nbsp;

70
00:06:15,490 --> 00:06:18,140
そして、私はこの第3の議論を私が望む数に変更することができます。

71
00:06:18,140 --> 00:06:24,140
だから0から5までの100個の等間隔の点が必要な場合は、それを渡すことができ、それははるかに大きな1次元配列を返します。

72
00:06:24,140 --> 00:06:26,470
&nbsp;

73
00:06:26,540 --> 00:06:30,800
&nbsp;

74
00:06:31,040 --> 00:06:35,870
&nbsp;

75
00:06:36,460 --> 00:06:40,220
そして、たとえそれが印字されているかのように見えるとしても、2次元を扱う際には、配列の前にブラケットが1つしかないということで、1次元であると言うことができます大括弧が2組あることがわかります。

76
00:06:40,220 --> 00:06:42,910
端部の開閉時。

77
00:06:42,980 --> 00:06:46,140
私が言及した3つの括弧などがあります 大丈夫。

78
00:06:46,310 --> 00:06:47,120
だからそれはいつの宇宙です。

79
00:06:47,120 --> 00:06:48,320
&nbsp;

80
00:06:48,320 --> 00:06:54,980
また、空間をリント空間と混同しないでください。3番目の引数には、その引数をステップサイズとして取り揃えたい点の数をとります。先に進み、piを使って恒等行列を作成する方法を示してください。

81
00:06:54,980 --> 00:07:01,430
&nbsp;

82
00:07:01,430 --> 00:07:04,960
n p e y eと言うことができます。

83
00:07:05,360 --> 00:07:08,680
そして、唯一の桁数の単位行列を作ります。

84
00:07:09,350 --> 00:07:13,570
使い慣れていない場合は、線形代数の問題を扱うときに便利な行列です。

85
00:07:13,580 --> 00:07:17,750
&nbsp;

86
00:07:17,900 --> 00:07:23,040
&nbsp;

87
00:07:23,040 --> 00:07:30,320
それは基本的には2次元の正方行列であり、行数は列数と同じであり、他のすべてがゼロである対角行列を持つため、引数として1桁の数字しか取らない理由です行列は出力として正方形でなければならず、P

88
00:07:30,320 --> 00:07:36,440
iでなければならない。

89
00:07:36,650 --> 00:07:38,340
今すぐpiに沿って動くすべての権利には、乱数の配列を作成するためのたくさんの方法があります。

90
00:07:39,170 --> 00:07:45,320
そして、私たちはコース全体でそれを頻繁に使用するつもりですので、それを行うためのいくつかの方法を説明しましょう。

91
00:07:45,380 --> 00:07:49,100
&nbsp;

92
00:07:49,100 --> 00:07:49,690
先に進むべきことは、Nと呼ぶことです。 P。 ランダムな点を見つけて、メソッドを実行しました。

93
00:07:50,090 --> 00:07:58,040
実際にはかなりの方法があることがわかります。

94
00:07:58,100 --> 00:08:01,520
だから私たちは行くとあなたに最も一般的なものを表示するつもりです。

95
00:08:01,580 --> 00:08:05,130
最初のものは蘭がaとbです。

96
00:08:05,660 --> 00:08:09,080
&nbsp;

97
00:08:09,590 --> 00:08:14,570
そして、これはあなたが渡す与えられた形状の配列を作成することになり、0から1までの一様分布から無作為標本をそれに入れるでしょう。

98
00:08:14,630 --> 00:08:19,620
&nbsp;

99
00:08:19,620 --> 00:08:24,950
つまり、0から1まで均等に分布した乱数の8次元の配列を8個だけ欲しければ、1桁で渡すことができ、その1次元配列を返すことになります。

100
00:08:24,950 --> 00:08:30,840
私はこれがそれに言及することができるようにしたい。

101
00:08:31,160 --> 00:08:34,760
以前の関数とは異なり、タプルを渡す代わりに作業しました。

102
00:08:35,030 --> 00:08:38,930
私は実際には次元を別々の引数として渡します。

103
00:08:38,950 --> 00:08:42,820
&nbsp;

104
00:08:42,860 --> 00:08:49,130
つまり、私が渡す乱数の行列を5行5行、5行をタプルの代わりに5つにして、これらのランダムなライブラリを使って作業したいということです。

105
00:08:49,130 --> 00:08:52,040
&nbsp;

106
00:08:52,400 --> 00:08:58,490
私たちがrandを使うことができるのではなく、Ranzを使う代わりに標準正規分布またはガウス分布からサンプルまたは多くのサンプルを返すなら、

107
00:08:58,490 --> 00:09:02,580
&nbsp;

108
00:09:03,030 --> 00:09:10,790
それは、PがRanのnをランダムに考えていると言うことができ、これは0から1までの一様分布からではなく、ゼロの周りの標準正規分布中心からの数値を返すと言うことを意味します。

109
00:09:10,790 --> 00:09:16,750
そして、それは私が先に進み、2つを渡すことができ、私は標準正規分布から2つの乱数を得ることを意味します。

110
00:09:17,060 --> 00:09:25,130
そして、後で我々は、この講義ではなく、これらをプロットするだけでなく、データの視覚化を得ることも見ていきます。

111
00:09:25,670 --> 00:09:30,140
私たちは先に進み、素敵な正規分布曲線またはガウス分布曲線を表示します。

112
00:09:30,560 --> 00:09:35,200
そして私がこれを二次元にしたいなら、二次元で渡すことができます。

113
00:09:35,950 --> 00:09:40,580
だから4人で4人は4人になると言う。

114
00:09:40,670 --> 00:09:43,540
&nbsp;

115
00:09:43,970 --> 00:09:49,070
そして、私はここでタプルを渡しません。私は別々の引数として言及するたびに渡します。そして、私は2つの括弧で囲まれたセットで出力と最終的なランダムなメソッドを作成します。

116
00:09:49,070 --> 00:09:57,020
Rand

117
00:09:57,200 --> 00:10:02,990
intについて学ぶつもりですが、それは低い数値から高い数値へのランダムな整数を返します。あるいは先に進み、そのためにできることを示します。

118
00:10:03,000 --> 00:10:06,140
あなたは先に進み、無作為なアシン・ランド1と言うでしょう。 A. あなたはパーザンでしょう。

119
00:10:06,140 --> 00:10:12,310
私はそのシフトタブにここでは低い、そして次にあなたが望む実際のサイズに行く。

120
00:10:12,360 --> 00:10:17,810
&nbsp;

121
00:10:17,810 --> 00:10:26,870
たとえば、1から100と言うと、1から100の間のランダムな整数が得られ、ローの値は包括的です。

122
00:10:26,930 --> 00:10:27,700
そして、高いxの排他的な意味は、選択される可能性がありますが、100はそうではありません。

123
00:10:27,750 --> 00:10:34,570
特定の数の乱数が必要な場合は、3番目の引数として渡すことができます。

124
00:10:35,540 --> 00:10:40,410
1から100までのランダムな整数になります。

125
00:10:40,400 --> 00:10:43,770
しかし100は含まない。

126
00:10:43,790 --> 00:10:45,160
&nbsp;

127
00:10:45,440 --> 00:10:50,930
私はちょうどそこを通過することができ、そこには10があり、ハイエンドでは排他的にローを含む10のランダムな整数があります。

128
00:10:50,930 --> 00:10:51,920
OK。

129
00:10:52,200 --> 00:10:52,820
これを行うために配列のいくつかの有用な属性とメソッドについて議論しましょう。

130
00:10:53,100 --> 00:10:59,350
私は先に進んで、2つの新しい配列オブジェクトを作成し、これをクリアしてこれらのセルをクリアします。

131
00:10:59,370 --> 00:11:05,450
大丈夫。

132
00:11:07,830 --> 00:11:08,630
私はr変数を言うつもりで、これは純粋な範囲25に等しいと言うでしょう。

133
00:11:08,630 --> 00:11:16,330
だから、もし私がA-Rのように見えるのであれば、24までの一次元の配列が0になります。

134
00:11:16,380 --> 00:11:22,220
そして、私はランドが本当にランダムであり、それがランドになると言うつもりです。

135
00:11:22,500 --> 00:11:30,660
そこにDを置くことになった。

136
00:11:31,000 --> 00:11:32,790
0から50までのランダムな整数。

137
00:11:32,960 --> 00:11:35,980
だから私はそれらの10を取得していない。

138
00:11:36,390 --> 00:11:37,930
&nbsp;

139
00:11:38,210 --> 00:11:44,040
だから私がChekaか走っているならこれはランダムに選択されているので、あなたは異なる値を得るかもしれないこのような外見のように見えます。

140
00:11:44,030 --> 00:11:44,690
これらは10個の整数しかありません。

141
00:11:44,690 --> 00:11:47,890
大丈夫。

142
00:11:48,020 --> 00:11:48,780
配列で使用できる最も便利なメソッドの1つは、変形方法です。

143
00:11:48,840 --> 00:11:53,130
そして、新しい形状であれば同じデータを含む配列を返します。

144
00:11:53,300 --> 00:11:57,770
&nbsp;

145
00:11:57,770 --> 00:12:07,930
つまり、私はミレイの点を呼ぶことができ、その上に形を変える方法が再構成され、私が望む新しい次元に合格します。

146
00:12:07,940 --> 00:12:08,940
たとえば、配列メンバーの形状を変更したい場合は、R Rはゼロから24の25桁です。

147
00:12:08,930 --> 00:12:16,940
私はreshapeを使って5行5列の配列に変更し、必要な行数と列数を渡します。

148
00:12:16,940 --> 00:12:24,350
&nbsp;

149
00:12:24,360 --> 00:12:25,780
その行列を完全に埋めることができない場合は、エラーが発生することに注意してください。

150
00:12:25,790 --> 00:12:30,630
たとえば、5×10が必要な場合は、そのために50個の要素が必要です。

151
00:12:30,620 --> 00:12:35,940
新しい配列の合計サイズが変更されていないため、ここでエラーが発生します。

152
00:12:36,200 --> 00:12:40,820
あなたが持っている数字だけを使っていっぱいにする必要があるか、これをチェックする素敵な簡単な方法があります。列の数と実際の要素数が等しい5倍の5倍の数です25。

153
00:12:40,940 --> 00:12:48,990
&nbsp;

154
00:12:48,990 --> 00:12:56,310
&nbsp;

155
00:12:56,370 --> 00:12:59,330
そして私はこの配列に25の要素があることを知っています。

156
00:12:59,450 --> 00:13:02,860
&nbsp;

157
00:13:02,900 --> 00:13:08,780
OKをクリックして、最大値または最小値を見つけたり、場所を見つけたりするための便利な方法をいくつか紹介しましょう。今後の講義では、さらに多くの操作について説明します。

158
00:13:09,200 --> 00:13:13,670
あなたが知っておくと便利なものがいくつかあります。

159
00:13:13,830 --> 00:13:15,880
だから私たちのランダムな配列をチェックしてください。

160
00:13:15,960 --> 00:13:17,880
もう1回。

161
00:13:17,880 --> 00:13:18,980
再度あなたの数字は異なるかもしれませんが、実際に問題ではないこの演習のために。

162
00:13:18,990 --> 00:13:24,030
あなたの配列の最大値を探したい場合。

163
00:13:24,120 --> 00:13:27,400
maxメソッドを呼び出すと、この配列の最大値が返されます。

164
00:13:27,440 --> 00:13:33,170
同様に、配列の最小値を取得する場合。

165
00:13:33,870 --> 00:13:37,340
minメソッドを呼び出すことができます。

166
00:13:37,350 --> 00:13:40,240
配列を見てみましょう。

167
00:13:40,280 --> 00:13:41,710
&nbsp;

168
00:13:41,730 --> 00:13:48,980
もう一度、最大値または最小値を指定することによって、最大値または最小値の位置を実際に把握することができます。

169
00:13:49,080 --> 00:13:50,490
&nbsp;

170
00:13:50,580 --> 00:13:59,660
私が実際にどのインデックス値がこのMaxであるかを知りたいのであれば、私はRanhがArgive Maxであり、最大値のインデックス位置を返すと言うことができます。

171
00:13:59,680 --> 00:14:04,750
だから、私は49がインデックス3に位置していることに気付く。

172
00:14:04,980 --> 00:14:08,270
だから0 1 2 3。

173
00:14:08,450 --> 00:14:11,310
私にはそこに49の所がある。

174
00:14:11,420 --> 00:14:12,930
&nbsp;

175
00:14:13,100 --> 00:14:18,470
もう一度同じことをすることができます。あなたが言うことができる分の値で、それは最小値のインデックス位置を返します。

176
00:14:18,470 --> 00:14:20,990
したがって、6はインデックスの場所で、最小値と最小値は3です。

177
00:14:21,000 --> 00:14:25,760
この場合。

178
00:14:25,760 --> 00:14:26,940
OK。

179
00:14:27,500 --> 00:14:28,130
そしてすぐにいくつかのより便利なメソッドと属性。

180
00:14:28,400 --> 00:14:31,820
&nbsp;

181
00:14:31,970 --> 00:14:39,050
あなたが言うことができるベクトルの形を理解したいと思えば、あなたは戻って形状を戻して形状を戻します。

182
00:14:39,060 --> 00:14:39,980
ここで私は25 Khamaを得て、それはその配列がちょうど1次元のベクトルであったことを示しています。

183
00:14:39,980 --> 00:14:47,910
もし私が先に進んでそれを形作ったら。

184
00:14:49,080 --> 00:14:50,960
だから私は5つずつ5つに形を変えて言って、それをRと同じにするつもりです。 またはr r。

185
00:14:51,140 --> 00:15:01,060
今私はそれのドット形状と呼ばれる二次元の行列を持っていることに注目してください。

186
00:15:01,160 --> 00:15:02,190
私はカッコを入れていないことに注意してください。

187
00:15:02,180 --> 00:15:07,340
私はそれから属性を呼び出すだけです。

188
00:15:07,350 --> 00:15:08,970
5分5秒ということが報告されました。

189
00:15:09,000 --> 00:15:11,350
&nbsp;

190
00:15:11,390 --> 00:15:14,360
それは今、そのMitchellにあります。私が今見せたい最後の有用な属性は、この配列のデータ型です。

191
00:15:14,450 --> 00:15:20,810
あなたが配列を持っているデータ型が好奇妙な場合は、r rと言うだけで、属性D型としてタイプすれば、実際のデータ型が返されます。

192
00:15:20,820 --> 00:15:21,690
&nbsp;

193
00:15:21,750 --> 00:15:28,410
この場合、32ビットの整数。

194
00:15:28,500 --> 00:15:32,700
OK。

195
00:15:32,720 --> 00:15:35,470
私たちが行ったことのすべてを素早く見直すだけです。

196
00:15:35,510 --> 00:15:36,000
&nbsp;

197
00:15:36,200 --> 00:15:38,660
リストを上位の配列にキャストするか、組み込み関数の1つをarrのような審判の配列に使うことによって、帝国醸造を作成する方法を示しました。

198
00:15:38,720 --> 00:15:45,390
ゼロと1つのLynの空間とI、またNと呼ばれるランダムな生成方法 P。 それらを走らせた後、Randは走って走りました。そして、他のランダムな方法のいくつかを実行しました。

199
00:15:45,380 --> 00:15:52,680
&nbsp;

200
00:15:52,670 --> 00:15:59,840
&nbsp;

201
00:15:59,850 --> 00:16:01,690
&nbsp;

202
00:16:01,730 --> 00:16:06,920
すべての権利と最後のヒントNPEランダムに入力する必要がない場合は、ランダムにインポートし、次にインポートするメソッドや関数をPIから言うことができます。

203
00:16:06,940 --> 00:16:16,200
あなたがRand I N Cをインポートしたければ、それを先に進めてやることができます。

204
00:16:16,190 --> 00:16:17,440
それから、ランダムな思考が私があなたに走ったと思うと言っているのではなく、ちょうどRand's Iを言うことができます。 A.

205
00:16:17,450 --> 00:16:20,900
私はあなた自身のための参照を持っています。

206
00:16:20,900 --> 00:16:27,480
そこに行く。

207
00:16:27,470 --> 00:16:30,020
OK。

208
00:16:30,020 --> 00:16:31,110
また、このコードのいずれか、またはこの講義を通して実際に話したノートのいずれかを参照したい場合は、すべてのノートがノートブックにあることを再度覚えておいてください。

209
00:16:31,190 --> 00:16:32,130
&nbsp;

210
00:16:32,250 --> 00:16:36,650
次回には、アンパイアレースのためのインデックス作成と選定、そして審判の操作について学びます。

211
00:16:36,680 --> 00:16:40,760
&nbsp;

212
00:16:40,760 --> 00:16:45,860
みんなありがとう、私は次の講演でお会いしましょう

213
00:16:45,870 --> 00:16:47,270
&nbsp;

214
00:16:47,270 --> 00:16:49,310
&nbsp;
