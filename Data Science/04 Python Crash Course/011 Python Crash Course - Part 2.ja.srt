1
00:00:05,220 --> 00:00:09,220
皆さん、こんにちは皆さん、Pythonのクラッシュコースの第2部にようこそ。

2
00:00:09,240 --> 00:00:12,240
木星ノートブックにジャンプして始めましょう。

3
00:00:12,660 --> 00:00:12,900
大丈夫。

4
00:00:12,900 --> 00:00:14,630
ここで私はノートブックのチップにいます。

5
00:00:14,640 --> 00:00:22,350
&nbsp;

6
00:00:22,350 --> 00:00:26,730
&nbsp;

7
00:00:26,760 --> 00:00:33,120
&nbsp;

8
00:00:33,210 --> 00:00:38,310
最後に、ネストされたリストから項目を取得する方法について説明しましたが、実際には要素のシーケンスであるため、文字列とリストのどちらを使用しても同じことができます。単にあなたが渡したリストは、あなたが望む実際のインデックスを括弧で囲み、そのインデックスまたはインデックスのスライスにある要素をグルーピングします。

9
00:00:38,310 --> 00:00:41,950
ギターを辞書について考えるように切り替えましょう。

10
00:00:42,030 --> 00:00:49,650
Pythonで中括弧を指定して辞書を作成すると、コロンとそのキーに対応する値を持つことになります。

11
00:00:50,010 --> 00:00:53,330
&nbsp;

12
00:00:53,430 --> 00:00:54,440
別の例を示してください。

13
00:00:54,450 --> 00:01:04,410
私たちは先に進んでコロン2つを作って、Q2の値は1から3の辞書がシーケンスの要素を保持するのではなく、ハッシュテーブルのようにキー値のペアとして動作します。

14
00:01:04,410 --> 00:01:09,830
&nbsp;

15
00:01:09,840 --> 00:01:14,630
それらはキーを介して要素を保持し、次にそれらの実際の値を保持します。

16
00:01:14,640 --> 00:01:20,910
だから、0のようなものを言うのではなく、そこにキーがなく、実際のシーケンス位置にそれを保持しないので、ブラケット記法で渡すことになるのは実際のものであり、値は返されません。

17
00:01:20,910 --> 00:01:26,250
&nbsp;

18
00:01:26,250 --> 00:01:30,420
&nbsp;

19
00:01:30,420 --> 00:01:36,000
たとえば、ここで123という数字を取得する場合は、辞書を呼び出してその値に対応するキーを渡します。

20
00:01:36,000 --> 00:01:38,200
&nbsp;

21
00:01:38,250 --> 00:01:45,150
この場合、1つの2つの3つの辞書と基本的には、その値として任意の項目を取り込むことができます。

22
00:01:45,240 --> 00:01:51,120
だからK-1のコロンが鍵となり、実際にはここに別のリストを持つことができます。

23
00:01:51,150 --> 00:01:52,900
一二三。

24
00:01:53,790 --> 00:02:00,170
そして今私が辞書を呼び出すと、私は一つの鍵K Kを持っていて、次にリスト2:59がその項目を持っています。

25
00:02:00,330 --> 00:02:04,590
だから私はK-1に電話して、そのリストを1つ2つ3つ返すことができます。

26
00:02:04,890 --> 00:02:08,740
そして今、私は実際に通常のインデックス作成を行うことができるこのリストを持っています。

27
00:02:08,880 --> 00:02:11,250
それはキーではなく、リストから外れています。

28
00:02:11,580 --> 00:02:13,600
それでは、2つをつかもう。

29
00:02:13,680 --> 00:02:19,230
どちらがインデックス1になるかは、基本的には2つのステップに分かれています。

30
00:02:19,650 --> 00:02:22,260
だから、あなたは何かのようにすることができます。

31
00:02:22,260 --> 00:02:26,030
私のリストはQ1のそのアイテムと同じです。

32
00:02:26,310 --> 00:02:31,800
そしてあなたがリストであった私のリストを見て、あなたがそのリストのために必要なものをつかむためにブリッケン表記法を使うならば、それを同じ行に沿って一歩一歩してください。エクササイズするか、ネストされた辞書やネストされたリストを作成します。

33
00:02:31,800 --> 00:02:39,090
&nbsp;

34
00:02:39,090 --> 00:02:45,000
&nbsp;

35
00:02:45,070 --> 00:02:49,620
&nbsp;

36
00:02:49,620 --> 00:02:58,180
&nbsp;

37
00:02:58,260 --> 00:03:04,140
私は別の辞書の中に実際に辞書を入れておくことができるもう一つの例を見せてくれるので、K-1コロン・パサンを他の辞書に入れて、中括弧のセットと内部キー・コロンのようなもの値。

38
00:03:04,140 --> 00:03:06,100
一二三。

39
00:03:06,120 --> 00:03:09,010
だから私はこの2番をつかみたいとしましょう。

40
00:03:09,390 --> 00:03:15,450
あなたがしなければならないことはまずK-1を呼び出すことです。それはこの辞書を返します。

41
00:03:15,450 --> 00:03:20,490
それから、私はコールインナーキーを必要とするので、別のブラケットセットを使用することができます。または、変数割り当てを使用して複数のステップに分割することができます。

42
00:03:20,490 --> 00:03:23,310
&nbsp;

43
00:03:23,310 --> 00:03:24,950
しかし、私たちはすべて1行でやります。

44
00:03:25,440 --> 00:03:32,640
そして今私は1つ2つ3つと2つは、0の2番目のインデックスとそこに2番をつかむことです。

45
00:03:32,640 --> 00:03:33,230
&nbsp;

46
00:03:33,570 --> 00:03:36,770
だから、辞書はどんな順序も保持しません。

47
00:03:36,770 --> 00:03:40,410
それらは単にキー値ペアのマッピングです。

48
00:03:40,410 --> 00:03:44,550
今ブール数十億とPythonについて話しましょう。

49
00:03:44,550 --> 00:03:50,610
それは正当なもので、大文字のTの場合はFalseであり、Fの場合は大文字になります。

50
00:03:50,640 --> 00:03:54,930
比較演算子について話し合ってみましょう。

51
00:03:54,960 --> 00:03:58,010
しかし、タプルについて話してから、セットを作ってみましょう。

52
00:03:58,110 --> 00:04:05,460
リストはカンマで区切られた大括弧で囲まれた一連の文字として定義されていることに注意してください。

53
00:04:05,460 --> 00:04:06,630
&nbsp;

54
00:04:06,930 --> 00:04:14,850
&nbsp;

55
00:04:14,850 --> 00:04:22,140
&nbsp;

56
00:04:22,140 --> 00:04:24,980
そして、あなたは先に進むことができ、そのリストからアイテムを取り出すことができます。タプルのインデックス付けは非常によく似ていますが、大カッコではなく、カッコを使用します。

57
00:04:25,020 --> 00:04:30,840
これらの括弧のタプルと角括弧のリストの主な違いは次のとおりです。

58
00:04:31,410 --> 00:04:40,800
私が私のリストに戻って、最初のアイテムを新しいリップスという言葉に再割り当てしようとすると、実際にはリスト全体が再割り当てされているので、もう一度これを実行させてください。

59
00:04:40,800 --> 00:04:44,060
&nbsp;

60
00:04:44,220 --> 00:04:46,410
リストをもう一度見てみましょう。

61
00:04:46,410 --> 00:04:46,620
大丈夫。

62
00:04:46,620 --> 00:04:48,850
私のリストをプリントアウトすると、私は1つ2つ3つ持っています。

63
00:04:48,990 --> 00:04:50,690
そのリストの最初の項目を取得します。

64
00:04:50,700 --> 00:04:52,060
ゼロ。

65
00:04:52,110 --> 00:04:52,890
完璧。

66
00:04:52,890 --> 00:04:57,750
今度は、以前の講義と同じようにゼロを再割り当てしてみましょう。

67
00:04:57,750 --> 00:05:06,210
そして今私のリストをチェックするために、私はタプルのためにそれをしたいならば、要素0を新しいものに、そして3に再割り当てしました。

68
00:05:06,210 --> 00:05:06,730
&nbsp;

69
00:05:06,730 --> 00:05:12,540
しかし、私たちのタプルを見れば、それは1つ2つです。3つは、新しいものに等しいのではなく、0をつかみましょう。私はエラーを起こすでしょう。

70
00:05:12,540 --> 00:05:13,870
&nbsp;

71
00:05:14,220 --> 00:05:18,780
これは、タプルが不変でアイテム割当をサポートしていないためです。

72
00:05:18,780 --> 00:05:23,250
つまり、タプルの中のアイテムを変更することはできません。

73
00:05:24,440 --> 00:05:29,610
これは、ユーザーがオブジェクトのシーケンス内のアイテムを変更できないようにする場合に、タプルを使用することを意味します。

74
00:05:29,670 --> 00:05:31,690
&nbsp;

75
00:05:31,740 --> 00:05:37,980
これはタプルとリストの主な違いです。タプルは不変であり、リストは変更可能であり、リスト内の項目を変更することができます。

76
00:05:38,220 --> 00:05:40,360
&nbsp;

77
00:05:40,500 --> 00:05:43,110
タプルなら同じことをすることはできません。

78
00:05:43,110 --> 00:05:43,740
大丈夫。

79
00:05:43,860 --> 00:05:51,360
今度はPythonのセットについて議論するために、セットはユニークな要素の集合です。

80
00:05:51,360 --> 00:05:55,580
そして、それはちょうど要素であるコロンを持たないことを除いて、辞書と同じ中かっこのように見えます。

81
00:05:56,850 --> 00:05:58,590
&nbsp;

82
00:05:58,590 --> 00:06:03,310
これらの数字のいくつかを複数回入力すると、何が起こるか気づくでしょう。

83
00:06:04,650 --> 00:06:10,130
セットは一意の要素だけで定義されているので、同じ出力が得られます。

84
00:06:10,290 --> 00:06:16,650
&nbsp;

85
00:06:17,090 --> 00:06:26,980
意味は、同じ要素の倍数を入れようとすると、それは固有の要素に還元され、実際には関数を呼び出すことができ、独自の要素を集めるためのリストを作ることができます。

86
00:06:27,040 --> 00:06:33,780
だから私は束縛された要素の束をset関数に渡し、それは一意の要素の集合を返します。

87
00:06:34,410 --> 00:06:40,060
あなたがセットに項目を追加したい場合は、先に進んで、インスタンスyesと言うことができます。

88
00:06:40,080 --> 00:06:47,790
1つ2つは3つです。■インスタンス5に追加するアイテムに追加メソッドを使用します。

89
00:06:47,790 --> 00:06:48,770
&nbsp;

90
00:06:48,900 --> 00:06:52,970
そしてそれをもう一度チェックすると1 2 3 5が得られます。

91
00:06:53,160 --> 00:07:00,600
5をもう一度追加しようとすると、エラーは取得されませんが、セット内で5つの一意のインスタンスしか許可されないため、同じままにします。

92
00:07:00,600 --> 00:07:04,160
&nbsp;

93
00:07:04,170 --> 00:07:04,470
大丈夫。

94
00:07:04,500 --> 00:07:07,440
本当にこのコースでは、セットでの作業が本当に必要です。

95
00:07:07,440 --> 00:07:09,010
しかし、私はあなたがそれらを知って欲しいです。

96
00:07:09,210 --> 00:07:11,940
それらはユニークな要素の集合です。

97
00:07:12,170 --> 00:07:12,780
OK。

98
00:07:13,080 --> 00:07:18,620
比較演算子の比較演算子では、2つの要素を比較することができます。

99
00:07:18,620 --> 00:07:19,440
&nbsp;

100
00:07:19,440 --> 00:07:23,320
これらは、以下よりも大きいものなどです。 たとえば、新しいセルを作ります。

101
00:07:24,210 --> 00:07:26,820
&nbsp;

102
00:07:26,820 --> 00:07:33,060
私は2つ以上の1つであると言うことができ、あなたのステートメントが何であるかに応じて、真または偽のブール値を返します。

103
00:07:33,060 --> 00:07:34,240
だから2つより多くが偽です。

104
00:07:34,250 --> 00:07:36,990
1が2未満の場合

105
00:07:37,040 --> 00:07:39,700
そして、あなたは同じ以上を、同じかそれよりも大きくても小さくしても同じことをすることができます。

106
00:07:40,200 --> 00:07:47,980
2つの等号を使って平等をチェックし、構文の強調表示の種類がここでどのように役立つかに気づくことができます。

107
00:07:48,000 --> 00:07:53,100
&nbsp;

108
00:07:53,100 --> 00:07:54,480
1つは1に等しい。

109
00:07:54,540 --> 00:07:55,770
それは本当です。

110
00:07:55,800 --> 00:07:56,880
1つは2で、それは偽です。

111
00:07:57,210 --> 00:07:59,410
違います。

112
00:07:59,430 --> 00:08:00,670
2つの等号を使用したいと思います。

113
00:08:00,690 --> 00:08:03,650
&nbsp;

114
00:08:03,660 --> 00:08:07,970
このようなことをしようとすると、実際の比較操作ではなく、変数の代入をしようとしているとPythonが考えているので、エラーが発生します。

115
00:08:07,980 --> 00:08:12,190
あなたが何らかの品質をチェックしたいのであれば。

116
00:08:12,330 --> 00:08:14,550
感嘆符は等号です。

117
00:08:14,550 --> 00:08:16,880
したがって、1つは3つに等しくありません。

118
00:08:16,920 --> 00:08:19,060
それは実際には本当です。

119
00:08:19,290 --> 00:08:20,500
&nbsp;

120
00:08:20,550 --> 00:08:25,830
1つが3に等しくないことは事実であり、数字だけでなく文字列でも同じことをすることができます。

121
00:08:27,180 --> 00:08:28,130
だから購入と同等の高いです。

122
00:08:28,170 --> 00:08:30,410
それは間違いです。

123
00:08:30,450 --> 00:08:31,070
それはそれと同じではないことは同じではありません。

124
00:08:31,080 --> 00:08:33,780
まあそれは本当です。

125
00:08:33,810 --> 00:08:35,450
&nbsp;

126
00:08:35,460 --> 00:08:40,380
ここで、これらの比較演算子を、andやthen、などの論理演算子と組み合わせる方法について説明します。

127
00:08:40,400 --> 00:08:42,900
今はただ一つの状態を見ているだけで、2つより少ない状態です。

128
00:08:43,010 --> 00:08:46,790
まあそれは本当です。

129
00:08:47,040 --> 00:08:48,300
&nbsp;

130
00:08:48,350 --> 00:08:53,900
3つよりも少ない2つの条件などと組み合わせたい場合は、キーワードを使用してそれを行うことができます。

131
00:08:53,970 --> 00:08:55,780
だから私は2つよりも少なく、3つより少ないと言うでしょう。

132
00:08:55,800 --> 00:09:00,790
そして、これは真実を返します。

133
00:09:01,080 --> 00:09:02,890
しかし、これらのうちの1つが偽に切り替わった場合、1つは2未満です。

134
00:09:02,940 --> 00:09:06,780
まあそれは本当であり、それは3よりも大きすぎます。

135
00:09:06,810 --> 00:09:09,520
間違ってみましょう。

136
00:09:09,560 --> 00:09:10,620
だからあなたは真実と偽を持っているか、偽を返します。

137
00:09:10,620 --> 00:09:14,970
したがって、and演算子のすべての条件が真でなければなりません。

138
00:09:14,970 --> 00:09:18,140
そして私は個人的にこれらのステートメントをかっこで囲みたい。

139
00:09:18,410 --> 00:09:22,440
だから、彼らはもう少し読みやすくなっています。

140
00:09:22,620 --> 00:09:24,020
&nbsp;

141
00:09:24,030 --> 00:09:28,290
あなたはそれをする必要はありませんが、後ほどこのコードに戻ってくるともう少し読めるので、私はあなたがすることをお勧めします。

142
00:09:28,290 --> 00:09:31,320
&nbsp;

143
00:09:31,320 --> 00:09:37,250
あなたはまた、実際には類似しているOR演算子を持っていますが、今の場合はそのうちの1つだけが真でなければなりません。

144
00:09:37,250 --> 00:09:37,790
だから、私たちは2つよりも少ないか、3つよりも多いと言うことができます。

145
00:09:37,860 --> 00:09:42,810
これらのうちの1つが真実です。

146
00:09:42,990 --> 00:09:45,330
最初のものはです。

147
00:09:45,330 --> 00:09:46,410
だから私たちは真実に戻る。

148
00:09:46,470 --> 00:09:47,990
&nbsp;

149
00:09:48,170 --> 00:09:54,300
そして、あなたは実際にお互いの上にこれらを積み重ねることができますので、他の人やここで私たちのために1つのequalsが等しいと言うことができます。 そして、あなたが本当に理解できるようにしたいのであれば、実際にはPassonsの真偽値が真実で真実であることを真実と偽に返します。真と偽False

150
00:09:54,300 --> 00:09:56,220
&nbsp;

151
00:09:56,410 --> 00:10:00,210
TrueまたはFalseは真です。

152
00:10:01,020 --> 00:10:13,850
だからちょうど。

153
00:10:13,910 --> 00:10:14,130
それでは、if else文があるかどうかについて話して、いくつかのコードブロックについて説明しましょう。

154
00:10:14,140 --> 00:10:15,030
&nbsp;

155
00:10:15,110 --> 00:10:24,990
条件が真であればコードを実行したくて、L文を残しておけばそれを使うことができます。

156
00:10:25,370 --> 00:10:32,060
1つが2未満の場合、条件があるとしましょう。

157
00:10:32,090 --> 00:10:34,450
私たちは、printステートメントのような何らかのアクションを実行する必要があります。

158
00:10:34,460 --> 00:10:40,830
私たちは先に進んで、ええと言うでしょう。

159
00:10:41,180 --> 00:10:45,510
だから、もしこの条件が真のコロンで、ここに空白のブロックがあることに気づいたら、それはPythonでは本当に重要です。

160
00:10:45,710 --> 00:10:47,620
&nbsp;

161
00:10:48,470 --> 00:10:55,370
Pythonはコード実行ステートメントのブロックを区切るために角括弧を使いません。

162
00:10:55,370 --> 00:10:56,990
代わりに空白を使用します。

163
00:10:57,020 --> 00:11:02,030
そしてコロンの後にここに「enter」と入力すると、自動的に木星の字下げが行われます。

164
00:11:02,030 --> 00:11:03,800
また、Pythonをサポートするほとんどのアイデアも同じことをします。

165
00:11:03,890 --> 00:11:08,640
私たちは持っています。

166
00:11:08,930 --> 00:11:12,920
もし何かが何らかのアクションを実行するよりも少なく、基本的には真の印刷がコードを実行するならばこれを言っているだけです。

167
00:11:12,920 --> 00:11:13,590
または、2つのプラス2つのプラス2つのプラス2などと言うことができるような項目を行うことができます そして、Xを見ると、それは4であることがわかります。

168
00:11:13,610 --> 00:11:24,290
つまり、if文だけです。

169
00:11:24,590 --> 00:11:26,260
したがって、条件が真であれば、コロンはその下に字下げされたコードブロックを実行します。

170
00:11:26,390 --> 00:11:34,340
大丈夫。

171
00:11:34,360 --> 00:11:37,020
今私たちができる他の操作について話してください。

172
00:11:37,100 --> 00:11:38,290
&nbsp;

173
00:11:38,300 --> 00:11:44,680
複数の条件をチェックしたい、あるいはそれが真でない場合に何かを起こしたいとしましょう。

174
00:11:44,680 --> 00:11:45,470
だから、もし私が最初にSupeのプリントと等しいなら、それ以外はColanプリントが最後になると言うでしょう。

175
00:11:45,620 --> 00:11:49,240
これが何をするのかは、この条件が真であるかどうかを言うために、このコードを別の方法で実行することになります。

176
00:11:49,520 --> 00:11:54,860
あるいは、上記の事柄のいずれも真実でなく、elseがif文とどのように並んでいるかに注意してください。if文は互いにリンクしています。

177
00:11:54,860 --> 00:11:55,600
&nbsp;

178
00:11:55,670 --> 00:12:12,400
Colin

179
00:12:12,440 --> 00:12:19,460
Crantzが最後にこのコードを実行すると、最後に実行され、最初の条件が真であることが最初に実行されるようにこれを切り替えると実行が終了します。

180
00:12:19,550 --> 00:12:26,180
今や、あなたは一つの条件だけでなく、いくつかの他のステートメントで複数の条件をチェックしたいかもしれません。

181
00:12:26,240 --> 00:12:28,230
それで、左を使って複数の条件をチェックすることができます。

182
00:12:28,330 --> 00:12:35,300
それで先に進むことができます。

183
00:12:35,300 --> 00:12:39,970
先に進み、似たようなことを言う。

184
00:12:39,980 --> 00:12:45,350
Elif 3は3に等しい。

185
00:12:45,770 --> 00:12:50,710
今度は最初のものをもう一度falseに変更しましょう。

186
00:12:51,530 --> 00:12:52,350
真ん中に印刷するものを印刷します。

187
00:12:52,370 --> 00:12:53,320
大丈夫。

188
00:12:53,350 --> 00:12:56,850
それでは、これを実行して、何が起こっているのかを解説しましょう。

189
00:12:56,870 --> 00:12:59,860
Pythonはこれを実行しています。この条件が真であれば、そうでなければこのコードブロックを実行します。

190
00:13:00,200 --> 00:13:04,660
あるいは、この条件が真である場合。

191
00:13:04,670 --> 00:13:05,030
このブロックコードを実行します。

192
00:13:05,030 --> 00:13:07,920
&nbsp;

193
00:13:07,930 --> 00:13:14,630
上記の条件のどれもが真でない場合は、このブロックコードを実行し、必要な数のステートメントをスタックしておき、ここで別のステートメントを言うことができます。

194
00:13:14,750 --> 00:13:18,030
Elifは外に出て、4人が4人のCrantz秒に等しいと言う。

195
00:13:18,230 --> 00:13:20,820
大丈夫。

196
00:13:20,840 --> 00:13:26,630
ここで何が起こるのか注目してください。

197
00:13:26,960 --> 00:13:29,910
これは本当ですが、3つは3に等しいです。

198
00:13:30,260 --> 00:13:38,210
真である条件の最初のインスタンスだけを実行します。

199
00:13:38,240 --> 00:13:38,530
&nbsp;

200
00:13:38,530 --> 00:13:39,990
これは、elifのelse文が最初の真の条件を実行する場合に使用するときに覚えておくことが重要なことです。

201
00:13:40,220 --> 00:13:43,500
大丈夫。

202
00:13:43,580 --> 00:13:47,580
これで2部目の講義シリーズが始まりました。次に、whileループとwhile

203
00:13:47,660 --> 00:13:52,190
Pythonのいくつかの関数について説明します。

204
00:13:52,190 --> 00:13:56,380
OK。

205
00:13:56,420 --> 00:13:56,960
&nbsp;

206
00:13:57,320 --> 00:14:03,140
私たちが何を行ったのかを簡単に見直すと、もう一度単なるキーのペアであるトップディクショナリに戻り、キーを入力することによって値を取得できます。

207
00:14:03,230 --> 00:14:05,310
辞書の中にネストされた辞書やネストされたリストを持つことができます。

208
00:14:05,690 --> 00:14:06,100
ブール値trueとfalseがあります。

209
00:14:06,140 --> 00:14:12,050
不変であるリストタプルがあります。

210
00:14:12,050 --> 00:14:15,880
&nbsp;

211
00:14:15,970 --> 00:14:20,340
タプルがアイテムの再割り当てをサポートしていないので、タプルの内部に入ったら、先に進んで変更することはできません。

212
00:14:20,780 --> 00:14:23,290
私たちはセットが唯一のユニークな要素の集合であることを覚えています。

213
00:14:23,420 --> 00:14:27,170
だから、あなたが繰り返し要素の束を持っていて、あなたがセットを持っているならば、それはちょうどユニークなものです。

214
00:14:27,440 --> 00:14:32,190
今度は、比較演算子が等しいかそれよりも小さい比較演算子を等価チェックよりも小さくしてから、不等式をチェックします。

215
00:14:32,190 --> 00:14:34,670
&nbsp;

216
00:14:34,670 --> 00:14:39,500
そして、あなたは同じことを文字列にすることができます。

217
00:14:39,500 --> 00:14:45,040
あなたはこれらの論理演算子を持っていますし、複数の条件文を比較することもできます。

218
00:14:45,410 --> 00:14:50,780
そして、あなたはスタックの種類にして、何らかの種類の条件に基づいてコードブロックを実行することを可能にするif elefant

219
00:14:50,780 --> 00:14:53,080
elseロジックを持っています。

220
00:14:53,120 --> 00:14:54,940
大丈夫。

221
00:14:55,010 --> 00:15:00,830
あなたはこの講義を楽しんで欲しいです。

222
00:15:01,070 --> 00:15:06,620
私たちは次の時にお会いします。

223
00:15:06,620 --> 00:15:10,230
&nbsp;

224
00:15:10,340 --> 00:15:11,420
&nbsp;

225
00:15:11,450 --> 00:15:12,730
&nbsp;

226
00:15:12,740 --> 00:15:14,060
&nbsp;
