1
00:00:05,130 --> 00:00:10,470
皆さん、こんにちは皆さん、PythonのクラッシュコースPart 1とPart

2
00:00:10,470 --> 00:00:14,270
1を歓迎します。基本的なデータ型を使って、Pythonについての議論を始めます。

3
00:00:14,280 --> 00:00:17,730
私が先に進んで、あなたがこの講義シリーズのノートブックにいたことが分かる場所を教えてください。

4
00:00:18,720 --> 00:00:22,010
ここで私はダウンロードし、解凍リポジトリにいます。

5
00:00:22,200 --> 00:00:28,190
あなたが先に進んでPythonクラッシュコースフォルダに行くと、ここに3つのノートがIPY inbyファイルであることがわかります。

6
00:00:28,220 --> 00:00:28,820
&nbsp;

7
00:00:28,830 --> 00:00:31,940
私たちはpythonクラッシュコースのノートブックで作業するつもりです。

8
00:00:31,940 --> 00:00:36,990
それをクリックすると、このようなノートブックが表示され、すべてのデータ型が処理されます。

9
00:00:36,990 --> 00:00:38,720
&nbsp;

10
00:00:38,790 --> 00:00:43,830
私たちは、数値ストリームの印刷リストの辞書のブール値のタプルとセットを調べることから始めます。

11
00:00:44,130 --> 00:00:45,680
私たちはどれだけ遠くに行くのかを見ていきます。

12
00:00:45,750 --> 00:00:48,200
後で、いくつかの高度な機能について説明します。

13
00:00:48,300 --> 00:00:54,910
私は先に進んで新しいノートブックをここに作り始め、準備を整えます。

14
00:00:55,110 --> 00:01:00,030
私は先に進み、見出しにあるものは、ヘッドバーで引っ張ってツールバーを切り替えて、もう少し余裕を持てるようにします。

15
00:01:00,030 --> 00:01:00,970
&nbsp;

16
00:01:01,140 --> 00:01:06,450
もう一度私がやっているのは、すべての例をここに入力して、コードを説明することです。

17
00:01:06,480 --> 00:01:07,330
&nbsp;

18
00:01:07,340 --> 00:01:12,220
だからもしリファレンスが必要な場合は、このレクチャーノートからコピー＆ペーストするだけです。

19
00:01:12,720 --> 00:01:12,990
大丈夫。

20
00:01:13,020 --> 00:01:20,280
先に進んで基本的な数値と算術を始めましょう。基本的な数値型は2つあります。

21
00:01:20,580 --> 00:01:23,350
1のような整数があります。

22
00:01:23,640 --> 00:01:27,540
そして、ポイントゼロのようなものである浮動小数点数があります。

23
00:01:27,540 --> 00:01:32,880
したがって、浮動小数点数には10進数が付いています。これらの数字のいずれかを使用すると、予想どおりの基本的な算術演算を実行できます。

24
00:01:32,880 --> 00:01:34,830
&nbsp;

25
00:01:34,840 --> 00:01:37,260
だから、追加のためだけにプラス記号です。

26
00:01:37,260 --> 00:01:43,740
1プラス1と私はちょうどシフトを入力しているそれは乗算のための細胞を実行しているので、アステリックスですので、1回3。

27
00:01:43,740 --> 00:01:45,400
&nbsp;

28
00:01:45,480 --> 00:01:46,950
そのようなアスタリスクだけ。

29
00:01:46,950 --> 00:01:52,340
ビジョンは、スラッシュを2で割ったものを0とするだけです。 5。

30
00:01:52,350 --> 00:01:54,370
そして、私が整数に入れても注意してください。

31
00:01:54,540 --> 00:02:00,300
あなたがPython

32
00:02:00,690 --> 00:02:03,090
2のユーザであれば、同じ結果を得るために、これらのうちの1つが浮動小数点数であることを確認する必要があります。

33
00:02:03,090 --> 00:02:08,480
私は指数のためだけに、例えば4の威力を持っています。

34
00:02:08,550 --> 00:02:10,450
ちょうど2つのアステリックスがまとめました。

35
00:02:10,470 --> 00:02:13,050
したがって、4の2乗は2です。

36
00:02:13,050 --> 00:02:20,430
これは2倍の2倍の2倍で、何か他に何か知っていることは、あなたが期待するようにPythonが操作の命令に従うということです。

37
00:02:20,430 --> 00:02:22,470
&nbsp;

38
00:02:22,500 --> 00:02:26,520
また、カッコを使用して実際に操作の順序を明確にすることができます。

39
00:02:26,670 --> 00:02:36,900
例えば、私が先に進んで、2つのプラス3つの5つのプラス5つの数学的な操作の順序は、実際に乗算が最初に発生することを宣言し、次に加算すると宣言します。

40
00:02:36,900 --> 00:02:41,030
&nbsp;

41
00:02:41,040 --> 00:02:45,120
私がこれを実行すると、15プラス2プラス5が得られます。

42
00:02:45,240 --> 00:02:47,430
だから、15プラス7は22です。

43
00:02:47,490 --> 00:02:52,890
&nbsp;

44
00:02:52,890 --> 00:03:00,300
&nbsp;

45
00:03:00,300 --> 00:03:04,850
実際に2つのプラス3のようなものを実際に言いたい場合は、5つのプラス5の結果を括弧を使って順序を明確にすることができます。このようにかっこを使用して実際に5回10回言うと50になります。

46
00:03:04,890 --> 00:03:08,570
私があなたに示したいと思う最後の算術演算は、モデル関数です。

47
00:03:08,820 --> 00:03:13,990
つまり、Ma'atの関数またはモジュラスはPythonのパーセント記号です。

48
00:03:14,610 --> 00:03:18,660
そして、それは基本的に分裂の後に残っているものを返すでしょう。

49
00:03:18,780 --> 00:03:22,010
したがって、2で割ったものは2つの余りです。

50
00:03:22,010 --> 00:03:23,210
ゼロ。

51
00:03:23,250 --> 00:03:33,030
だから、あなたが2人で分けたアウトプットが、残りの4人に1人が5人になるのでゼロになるでしょう。

52
00:03:33,390 --> 00:03:36,400
&nbsp;

53
00:03:36,500 --> 00:03:38,510
それであなたは残りの1を手に入れます。

54
00:03:38,550 --> 00:03:47,480
これは、たとえmod 2が0を返しても、8が偶数でないことがわかるように、数値が同じであるかどうかを調べるうえで便利です。

55
00:03:47,500 --> 00:03:49,510
&nbsp;

56
00:03:49,530 --> 00:03:54,630
2つはその数に均等に行き、残りのゼロがあるからです。

57
00:03:54,930 --> 00:03:58,910
変数の割り当てについてすぐに話しましょう。

58
00:03:59,160 --> 00:04:04,680
いくつかのオブジェクトやデータ型を変数名に割り当てるために、変数名を選びたいと思っています。

59
00:04:04,680 --> 00:04:05,270
&nbsp;

60
00:04:05,400 --> 00:04:08,150
Pythonでは代入演算子は等号にすぎません。

61
00:04:08,400 --> 00:04:11,790
変数を入力するだけで、変数の名前を選択します。

62
00:04:11,790 --> 00:04:17,160
V-Aのように、それらはすべて等しいと言い、そこに入れるオブジェクトの種類を表します。

63
00:04:17,160 --> 00:04:23,880
例えば、私たちは2つを入れて、その変数名をV A

64
00:04:23,880 --> 00:04:25,380
Rと呼ぶときはいつでも、2つを得ることができます。

65
00:04:25,380 --> 00:04:31,550
例えば、xは2と等しいと言うことができます。yは3に等しくなります。

66
00:04:31,740 --> 00:04:36,530
そして今、私は実際にXプラスYと言って5を出すことができます。

67
00:04:36,630 --> 00:04:41,730
私はそれ自身でそれを定義することによってXを再割り当てすることもできます。

68
00:04:41,760 --> 00:04:48,030
だから、xはxとxが等しいので、xが4に等しいので、xとxの和がxに等しいと言うことができます。

69
00:04:48,060 --> 00:04:53,280
そして、今度はXをもう一度呼び出すたびに、それを実行するたびにXをxプラスXに置き換えて、そのセルを再び実行すると4に等しいことになります。

70
00:04:53,760 --> 00:04:57,560
&nbsp;

71
00:04:57,630 --> 00:05:04,080
だから本質的にxの値を2倍にしようとすると、Xをすべて2倍の値に再割り当てすることになります。

72
00:05:04,530 --> 00:05:05,070
大丈夫。

73
00:05:05,280 --> 00:05:07,560
これらの変数名の作成に関する2つのルール。

74
00:05:07,560 --> 00:05:14,270
彼らは数字で始めるべきではないので、12 V-Aのようなものは12に等しいとは言えません。

75
00:05:14,400 --> 00:05:19,890
さもなければ、o'Warで構文エラーが発生します。無効な構文であることを知っています。

76
00:05:20,130 --> 00:05:26,160
だからあなたは数字で始めることはできませんし、特別な記号で始めることもできないので、Dollar

77
00:05:26,160 --> 00:05:35,110
Sign vrのようなことは言えません。ここで問題が起き始めるので、構文の誤りが出ます。

78
00:05:35,100 --> 00:05:40,190
複数の単語を連鎖したい場合は、小文字で始める必要があります。

79
00:05:40,290 --> 00:05:45,960
アンダースコアを区切るにはアンダースコアを使用する必要があります。

80
00:05:45,990 --> 00:05:50,950
他の言語では、ピリオドをピリオドで区切るためにどのようにピリオドを使用しますか？

81
00:05:50,970 --> 00:05:54,180
適切な構文は、アンダースコアを使用することです。

82
00:05:54,180 --> 00:05:57,110
さあ、文字列について話しましょう。

83
00:05:57,530 --> 00:06:03,570
ですから、文字列にハッシュタグを入れ、その前にハッシュタグを付けてコメントをつけます。

84
00:06:03,570 --> 00:06:03,990
&nbsp;

85
00:06:03,990 --> 00:06:09,330
あなたは色が違っていることに気づくでしょうし、それがコメントであるので、それは実行されないだけです。

86
00:06:09,320 --> 00:06:10,720
だからここに何でも入力できます。

87
00:06:10,740 --> 00:06:12,060
実行されません。

88
00:06:12,060 --> 00:06:17,250
さあ、文字列に移動してみましょう。私は先に進んで少し拡大して、これをよりよく理解できるようにします。

89
00:06:17,250 --> 00:06:19,590
&nbsp;

90
00:06:20,310 --> 00:06:23,460
また、文字列には文字列を作成する2つの方法があります。

91
00:06:23,700 --> 00:06:30,930
一重引用符を使用して、これが文字列であるか、二重引用符を使用できるKadingの色がどのように変化しているかに注意してください。これは文字列です。

92
00:06:30,930 --> 00:06:35,190
&nbsp;

93
00:06:35,940 --> 00:06:41,670
&nbsp;

94
00:06:41,670 --> 00:06:47,470
そして、二重引用符を一重引用符で囲むこともできます。そうすれば、私はcantsのように何かを言う文があるとしましょう。

95
00:06:47,610 --> 00:06:54,150
だから、もしあなたがこの一重引用符を持っていて、それを内部に入れたいのであれば、二重引用符で囲むことができます。その一重引用符が文字列内に保持されます。

96
00:06:54,150 --> 00:06:58,690
&nbsp;

97
00:06:58,710 --> 00:07:03,390
&nbsp;

98
00:07:03,390 --> 00:07:09,000
&nbsp;

99
00:07:09,000 --> 00:07:10,420
だから、文字列の中に一重引用符や二重引用符が必要な場合には、二重引用符と一重引用符のどちらか一方だけを囲むことができます。

100
00:07:10,810 --> 00:07:15,330
文字列の印刷について説明しましょう。

101
00:07:15,330 --> 00:07:22,740
私はXという変数をJupiterノートブックの文字列helloという記号にするつもりです。ただXと入力すると表示され、次にHelloの引用符を表示します。

102
00:07:22,740 --> 00:07:28,950
&nbsp;

103
00:07:28,950 --> 00:07:32,880
これは、変数xを入力するだけで、これをPythonのコンソールに直接入力した場合と同じです。

104
00:07:33,150 --> 00:07:35,290
&nbsp;

105
00:07:35,420 --> 00:07:42,510
文字列helloやPythonを置いておきますが、Xの出力を実際に出力したい場合はprint関数に渡す必要があります。print関数はカッコを表示し、次にxをそれらのカッコ内に渡します。

106
00:07:42,510 --> 00:07:48,030
&nbsp;

107
00:07:48,030 --> 00:07:48,980
&nbsp;

108
00:07:49,200 --> 00:07:49,590
そして注意してください。

109
00:07:49,590 --> 00:07:50,540
今ここの違い。

110
00:07:50,580 --> 00:07:55,410
私はそれ以上の指標を持っていないし、私はもはや単一引用符を持っていない。

111
00:07:55,500 --> 00:08:00,840
Pythonで結果を表示しようとしているときに、これをprint文として公式に表示する方法です。

112
00:08:00,870 --> 00:08:02,340
&nbsp;

113
00:08:02,340 --> 00:08:06,370
では、印刷文をどのように書式設定するかを説明します。

114
00:08:06,390 --> 00:08:15,180
変数名が12で、名前がSamと等しいとします。

115
00:08:15,180 --> 00:08:18,990
今私は実際にこれらの変数に基づいて物を印刷したいと思います。

116
00:08:19,260 --> 00:08:21,790
私は印刷フォーマットでそれを行うことができます。

117
00:08:22,230 --> 00:08:32,800
私は文字列を取って、私の番号がだと言うでしょう、そして、私は引用符または中括弧のブロックをそこにpasanします。

118
00:08:33,400 --> 00:08:39,770
そして私の名前は、私は中括弧の別のセットを渡すつもりです。

119
00:08:40,020 --> 00:08:46,320
そして、mislay

120
00:08:46,320 --> 00:08:52,290
dots形式で、これが文字列の特別な方法であることを示すためにここに色付けされていることに注意してください。そして、次に進むことができます。中括弧。

121
00:08:52,500 --> 00:08:56,380
&nbsp;

122
00:08:56,430 --> 00:09:03,810
だからちょうどこれをタイプしてこれを実行すると、Pythonがしていることは、文字列に中括弧が入っていて、あなたがそのフォーマットを持っていて、それを望む順番に並べるということです。

123
00:09:03,900 --> 00:09:08,480
&nbsp;

124
00:09:08,550 --> 00:09:14,440
だから、ここでは大括弧で置き換えられ、名前はここで置き換えられます。

125
00:09:14,460 --> 00:09:15,790
これらの中かっこの場合。

126
00:09:15,930 --> 00:09:21,480
これは、12またはSamを常時書き込むのではなく、印刷文で変数名を使用する便利な方法です。

127
00:09:21,480 --> 00:09:24,610
&nbsp;

128
00:09:24,930 --> 00:09:27,400
そして、私は実際にまだこれを印刷していないことに注意してください。

129
00:09:27,480 --> 00:09:31,320
私はこの全文を印刷ステートメントの周りにラップする必要があります。

130
00:09:31,320 --> 00:09:35,760
あなたの王子がバランスを保っていることを確認し、緑色に強調表示される印刷プリンスの1つを選択するだけで見ることができます。

131
00:09:35,760 --> 00:09:37,540
&nbsp;

132
00:09:37,600 --> 00:09:43,860
&nbsp;

133
00:09:43,860 --> 00:09:52,050
今私がこれにいたなら、これは本当に印刷されています。私はもはやあなたが印刷フォーマットを使うことができるもう一方の方法を売っていません。これを変えて中括弧に変数を渡すことができます。

134
00:09:52,350 --> 00:09:54,010
&nbsp;

135
00:09:54,420 --> 00:10:00,980
だから私は中括弧の内側と中括弧の内側の2つを言うことができます。

136
00:10:01,170 --> 00:10:08,070
そして、私がこれらの名前を渡したので、私はdoc形式の文の中に進んでいくことができます。

137
00:10:08,250 --> 00:10:11,380
&nbsp;

138
00:10:11,430 --> 00:10:17,910
この場合、私はそれがそんなに麻痺しないようにしたい、そして2つは私がそれが名前に等しいことを望みました。

139
00:10:18,000 --> 00:10:20,850
そして、私がこれを実行すると、私はまったく同じ結果を得るでしょう。

140
00:10:20,850 --> 00:10:26,580
&nbsp;

141
00:10:26,790 --> 00:10:34,440
&nbsp;

142
00:10:34,440 --> 00:10:41,420
&nbsp;

143
00:10:41,420 --> 00:10:47,280
これについて気に入っているのは、もはやあなたが中括弧に必要なものと全く同じ順序で書式設定されていることを心配する必要がなくなり、中括弧を継続的に入れて、次にもう一度タイプしてPython変数を一度だけ検索して置くことができるので、ここでは変数名を見て、次にあなたのフォーマットとチェックに行きます。

144
00:10:47,300 --> 00:10:49,190
変数名は何ですか？

145
00:10:49,190 --> 00:10:52,970
したがって、ここでは2は名前が2と等しいことを示しています。

146
00:10:53,000 --> 00:10:53,230
大丈夫。

147
00:10:53,240 --> 00:10:57,880
そしてここに名前を記入し、その名前が文字列Samと等しいことを知っている。

148
00:10:57,890 --> 00:11:00,640
それで先に進み、それをそこに置きます。

149
00:11:00,650 --> 00:11:03,080
さあ、どうぞ質問を投稿してください。

150
00:11:03,080 --> 00:11:07,670
Q＆Aフォーラムでは、この印刷物の書式について混乱しているが、基本的には簡単です。

151
00:11:07,790 --> 00:11:10,440
あなたの中かっこをあなたのひもに入れてください。

152
00:11:10,560 --> 00:11:15,020
次に、この形式の変数名を渡す方法を使用することをお勧めします。なぜなら、あなたが戻ってくるときにもう少し明確で、この形式の呼び出しの中で順序を乱すことを心配する必要がないからです。

153
00:11:15,020 --> 00:11:19,430
&nbsp;

154
00:11:19,430 --> 00:11:21,750
&nbsp;

155
00:11:21,770 --> 00:11:27,080
さあ、文字列のトピックをインデックス文字列に展開しましょう。

156
00:11:27,230 --> 00:11:33,780
私はSと呼ばれる文字列を持っていて、xはこんにちはと等しいと言うでしょう。

157
00:11:34,230 --> 00:11:37,140
Sは単なる要素のシーケンスです。

158
00:11:37,140 --> 00:11:44,990
そして、この場合、各要素は文字であり、この角括弧表記を使用して索引付けすることで、その文字列から特定の要素を取得できます。

159
00:11:46,010 --> 00:11:49,730
&nbsp;

160
00:11:49,730 --> 00:11:51,400
Pythonessはゼロから始まります。

161
00:11:51,440 --> 00:11:59,210
そして、これは、私がXで角括弧を0にしてこれを実行するかゼロ要素を戻すかを知るためのものです。

162
00:11:59,300 --> 00:12:00,180
&nbsp;

163
00:12:00,470 --> 00:12:07,570
だから、ここでは、それがグラブであることを確認します。こんにちは、要素があるとチェックし、0を返します。

164
00:12:07,700 --> 00:12:12,140
先に進み、ヒロの最後の場所をつかむことができるかどうかを見てください。

165
00:12:12,380 --> 00:12:20,830
まあ、スペーサーの指標が0 1 2 3 4であることはどういうことでしょうか？

166
00:12:21,710 --> 00:12:27,370
あなたはこれらの括弧の中に4つを入れ、それをつかみます。

167
00:12:27,380 --> 00:12:33,050
他に注意すべき点は、スライス表記と呼ばれるものを実際に文字列のスライスを取得するために使用できることです。

168
00:12:33,110 --> 00:12:34,600
&nbsp;

169
00:12:34,760 --> 00:12:38,980
私は先に進んで、こんにちはの美学の代わりに入力するつもりです。

170
00:12:39,020 --> 00:12:44,410
私はb c d e f g h i j kと言うでしょう。

171
00:12:45,020 --> 00:12:50,300
私はそれを実行し、今私は先に進んで、私が0のsを入力するかどうかを見るつもりです。

172
00:12:50,330 --> 00:12:53,000
この括弧の中に私は背を向けなければなりません。

173
00:12:53,300 --> 00:12:54,600
OKです。

174
00:12:54,770 --> 00:13:00,470
私はa以上のすべてをつかみたいとしましょう。

175
00:13:00,770 --> 00:13:05,380
まあ、これを行うにはスライスシンタックスとも呼ばれるコロン表記を使用することができます。

176
00:13:05,430 --> 00:13:09,810
私は結腸のようにsの0と言うでしょう。

177
00:13:09,920 --> 00:13:15,360
これを実行すると、このコロンは基本的に0から始まるOKと言います。

178
00:13:15,530 --> 00:13:22,200
それ以上のものはすべて掴み、この表記法は逆に働きます。

179
00:13:22,400 --> 00:13:27,770
私はコロンですべてのものをある指数までつかむと言うことができます。

180
00:13:27,770 --> 00:13:31,210
それでは、私がb c dと言うことを考えてみましょう。

181
00:13:31,370 --> 00:13:35,660
したがって、Dはインデックス3 0 1 2 3です。

182
00:13:35,780 --> 00:13:43,250
私がここで3つを渡すと、これは基本的にPythonがOKをすべて取得し、インデックス3は含まないと言うように命令しています。

183
00:13:43,250 --> 00:13:45,370
&nbsp;

184
00:13:45,380 --> 00:13:49,500
これは初心者のためにdが現れることを期待しているので混乱することがあります。

185
00:13:49,520 --> 00:13:54,860
&nbsp;

186
00:13:54,860 --> 00:14:01,710
索引の位置は3ですが、索引付けがゼロから始まるので、このコマンドを、文字要素索引3まで含めて、すべてを把握すると考えるべきです。

187
00:14:01,880 --> 00:14:05,900
そして、私たちは同じ考え方なので、リストについて話すときに表記をスライスすることについてもっと詳しく説明します。

188
00:14:05,900 --> 00:14:08,340
&nbsp;

189
00:14:08,420 --> 00:14:14,630
&nbsp;

190
00:14:14,930 --> 00:14:23,700
最後に、これらの2つのアイデアをここから始めて、それを超えてすべてを掴んだり、すべてのものをつかんだり、特定のインデックスポイントを含まないものをゼロから始めるようにしたりします。

191
00:14:24,190 --> 00:14:29,150
Colinは3つのような特定の指標まですべてをつかむ。

192
00:14:29,240 --> 00:14:31,380
今はABCと同じ結果を返します。

193
00:14:31,400 --> 00:14:37,090
しかし、私ができることは、これら2つの数字を置き換えて、私のスタートポイントとエンドポイントを設定することです。

194
00:14:37,130 --> 00:14:43,440
先に進んでD E Fをつかみ、dがインデックス3から始まるようにしましょう。

195
00:14:43,910 --> 00:14:50,090
私が先に進んでこれを置き換えると、私はインデックス3 0 1 2

196
00:14:50,090 --> 00:14:52,220
3で始めるつもりです。そして、Gを含めて上に行くつもりです。

197
00:14:52,250 --> 00:15:00,030
だから0 1 2 3 4 5 6 7と言うと3コロン6。

198
00:15:00,290 --> 00:15:02,840
それを実行して、私はd e fを得る。

199
00:15:02,870 --> 00:15:06,580
もう一度それはあなたがコロンを含んでいるところから始まるインデックスです。

200
00:15:06,590 --> 00:15:12,170
つまり、最後までインデックスを作成しておけば、インデックス作成がゼロから始まるため、インデックスに含めないでください。

201
00:15:12,200 --> 00:15:13,670
&nbsp;

202
00:15:13,760 --> 00:15:17,180
したがって、インデックス6にもgは含まれません。

203
00:15:17,450 --> 00:15:26,840
OKはこのアイデアを繰り返し述べていますが、これについては今すぐリストアップしています。リストは角カッコで囲まれた正方形の括弧で囲まれた一連の要素です。

204
00:15:26,900 --> 00:15:32,560
&nbsp;

205
00:15:32,570 --> 00:15:39,270
ここでは、基本的にどのデータ型でも3つのリストのうちの1つのリストを取ることができます。

206
00:15:39,710 --> 00:15:45,130
だから私はまた、文字列のリストを持つことができますし、ここに苦情はありません。

207
00:15:45,260 --> 00:15:58,460
私は先に進んで私のリストと呼ばれる変数を作り、それをb

208
00:15:58,460 --> 00:16:03,020
cと同じに設定します。リストの最後に要素を追加したい場合は、appendメソッドを使います。

209
00:16:03,080 --> 00:16:06,950
私はアンダースコアリストに追加すると言う。

210
00:16:07,310 --> 00:16:09,630
そして、私が文字Dを追加したいとしましょう。

211
00:16:09,950 --> 00:16:13,350
私はちょうどそれを実行し、今私のリストをチェックすれば。

212
00:16:14,300 --> 00:16:16,490
今、その価値に何が追加されましたか？

213
00:16:16,490 --> 00:16:22,160
Dまた、リストはストリングと同様のシーケンスです。

214
00:16:22,220 --> 00:16:27,350
&nbsp;

215
00:16:27,350 --> 00:16:34,940
&nbsp;

216
00:16:34,940 --> 00:16:38,230
意味私はリストの最初の項目をつかみたい場合は、私は文字列を渡して私はWatzはこれを実行し、私はインデックスでアイテムを返すので、各インデックスポイントコンマで区切られていません。

217
00:16:38,450 --> 00:16:44,300
例えば、私がbとcをつかみたいのであれば、同じスライス表記を使うことができます。

218
00:16:44,540 --> 00:16:51,730
私はインデックス1から始まり、インデックス3までを含めてすべてに行きたいと思います。

219
00:16:51,740 --> 00:16:57,290
だから私はコロン3がBとCを返さないと言うでしょう。

220
00:16:57,740 --> 00:17:02,550
このインデックス表記を使用してポジションを再割り当てすることもできます。

221
00:17:02,660 --> 00:17:08,360
最初の要素を別のものにしたいのであれば、アンダースコアのリストをpasandゼロでこれらの角括弧に入れて、必要な要素を渡します。

222
00:17:08,360 --> 00:17:13,380
&nbsp;

223
00:17:13,520 --> 00:17:16,390
私はその要素が今では新しいものにしたい。

224
00:17:16,390 --> 00:17:20,340
だから私が私のリストをつかむと、私は新しいB C Dを見る。

225
00:17:20,870 --> 00:17:28,550
ここで注意すべき点は、リストを互いに入れ子にすることができるので、コンマにカンマを1つしか書けず、別のリストにカンマを3つ入れることができます。

226
00:17:28,560 --> 00:17:34,750
&nbsp;

227
00:17:34,790 --> 00:17:39,440
だから私がリストを見れば、それはリストの中のリストだ。

228
00:17:39,440 --> 00:17:44,400
実際、私はこれを一つの要素として捉えたいとしましょう。

229
00:17:44,570 --> 00:17:48,770
それはインデックスのリストです。

230
00:17:48,830 --> 00:17:52,650
だから私はここに進み、これは他のリストに戻る。

231
00:17:52,850 --> 00:17:59,270
だから私は良い今のインデックス0

232
00:17:59,840 --> 00:18:03,680
1のグラフをしたいとしましょう私は別の括弧1のセットをタックし、実際の要素を取得することができます。

233
00:18:03,710 --> 00:18:08,970
私が入ってきて、ネストされたリストから物を掴むもう一つの例をあなたに教えてください。

234
00:18:08,990 --> 00:18:12,530
あなたはあまり頻繁にそれほど頻繁にこれをやっていません。

235
00:18:12,530 --> 00:18:20,570
しかし、私はちょうどあなたが複数の括弧を使うというアイデアを得ることを望むので、私はこのような入れ子リストを持っているとしよう。

236
00:18:20,570 --> 00:18:22,070
&nbsp;

237
00:18:22,070 --> 00:18:23,590
一二三。

238
00:18:23,600 --> 00:18:26,670
他のリストは4つまたは5つのリストが対象です。

239
00:18:27,020 --> 00:18:34,220
3番目または4番目の要素を取得して、ネスティングリストの3つ目のインデックスにすることができます。

240
00:18:34,220 --> 00:18:35,430
それはこのように見えます。

241
00:18:35,480 --> 00:18:41,280
それから私は別の1つを目標リストである0 1 2へのインデックスに設定することができます。

242
00:18:41,330 --> 00:18:44,350
そして、私はそのターゲットリスト内の唯一の要素がほしいとしましょう。

243
00:18:44,360 --> 00:18:47,920
いいえ、それはまだまさにpasanゼロの周りに角括弧があります。

244
00:18:47,960 --> 00:18:49,700
そして今、私は文字列のターゲットを持っています。

245
00:18:49,910 --> 00:18:54,980
この文字列を印刷したい場合は、この全部をprintステートメントで囲むことができます。

246
00:18:54,990 --> 00:18:56,590
今私は目標をつかむ。

247
00:18:56,600 --> 00:19:00,250
ネストされたリストで何かを見つけなければならない運動があります。

248
00:19:00,260 --> 00:19:05,460
だから、これらのブラケットの種類が互いに重なっていることを理解していることを確認してください。

249
00:19:05,480 --> 00:19:05,930
大丈夫。

250
00:19:06,170 --> 00:19:08,260
さあ、もう一度、パート1のためにここに立ち寄ってください。

251
00:19:08,330 --> 00:19:12,800
次に、この講義ではさらにいくつかのデータ型について説明します。スライス表記法では、索引文字列を取得する方法について説明します。

252
00:19:12,980 --> 00:19:17,120
&nbsp;

253
00:19:17,120 --> 00:19:22,770
どのようにしてこの基本的な変数の割り当てと基本的な算術の書式設定が行われましたか？

254
00:19:23,030 --> 00:19:23,820
OK。

255
00:19:23,900 --> 00:19:25,370
あなたはこの講義を楽しんで欲しいです。

256
00:19:25,370 --> 00:19:27,880
次に来て、もう少し先に行くつもりです。

257
00:19:27,890 --> 00:19:28,640
みんな、ありがとう。

258
00:19:28,640 --> 00:19:29,480
次の講演を見る
