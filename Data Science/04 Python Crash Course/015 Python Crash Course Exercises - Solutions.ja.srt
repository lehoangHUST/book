1
00:00:05,130 --> 00:00:10,810
皆さん、こんにちは皆さん、Pythonのクラッシュコースの演習の講義と講義を歓迎します。私はちょうどソリューションのノートブックとコードとソリューションを説明しています。

2
00:00:10,800 --> 00:00:15,180
&nbsp;

3
00:00:15,170 --> 00:00:20,440
いいえ、実際にこれをコーディングすることができるように、運動ノートにジャンプしましょう。

4
00:00:20,490 --> 00:00:20,760
大丈夫。

5
00:00:20,760 --> 00:00:23,990
ここで私はクラッシュコースの練習をしています。

6
00:00:24,060 --> 00:00:28,250
私たちが答えたい最初の質問は、7：2が4の威力であることです。

7
00:00:28,350 --> 00:00:30,540
これを行うには、技術的に2つの方法があります。

8
00:00:30,570 --> 00:00:36,900
あなたはちょうど7回7回7回7回入力して正しい答えを得ることができました。

9
00:00:36,910 --> 00:00:42,600
しかし指摘のためにアステリックスに電話している正しい方法を覚えておいてください。

10
00:00:42,660 --> 00:00:44,740
だから7の4の力に。

11
00:00:44,910 --> 00:00:47,730
そのセルを実行するとあなたの答えがあります。

12
00:00:47,730 --> 00:00:50,770
次は、Sと等しい文字列を分割したいと考えています。

13
00:00:50,780 --> 00:00:57,540
こんにちはSamさんがリストに入って、これを手に入れて実際に作成したい出力リストの例を見ることができます。

14
00:00:57,540 --> 00:00:59,890
&nbsp;

15
00:00:59,910 --> 00:01:06,750
だから、もし私がそこにサムを置いてエストープを呼び出すという続編を実行すると、これは自動的に文字列を空白のリストに分割します。

16
00:01:07,320 --> 00:01:09,790
&nbsp;

17
00:01:09,790 --> 00:01:15,840
たとえば、私たちは実際には文字列を実際に渡すことができることを覚えています。実際に分割したいものに、後で別の行使で実際にそれを見ることができます。

18
00:01:15,870 --> 00:01:19,750
&nbsp;

19
00:01:19,980 --> 00:01:25,380
変数plenaが地球に等しいという与えられた次の質問に進み、直径は2万740の2に等しい。

20
00:01:25,380 --> 00:01:27,850
&nbsp;

21
00:01:28,110 --> 00:01:30,710
この形式を使用して、次の文字列を出力します。

22
00:01:30,840 --> 00:01:34,830
地球の直径は2万740キロメートルです。

23
00:01:34,940 --> 00:01:41,220
&nbsp;

24
00:01:42,000 --> 00:01:49,500
そして、私たちがこれらの2つの変数を見つけられるようにセルを動かして行くと、私は文字列で地球の直径が千七百四十二キロになると言います。

25
00:01:49,520 --> 00:01:53,860
私はその形式を使用したいと思います。これらの2つの変数が必要です。

26
00:01:54,060 --> 00:02:02,070
&nbsp;

27
00:02:02,800 --> 00:02:11,280
&nbsp;

28
00:02:11,280 --> 00:02:13,460
だから私は地球を大括弧のペアで置き換え、この直径の数字についても同じことを行い、そのフォーマットを言うつもりで、私は地球の惑星の直径になり、私は先に進み、すべてを印刷します。

29
00:02:13,470 --> 00:02:14,950
それはこの作品です。

30
00:02:15,030 --> 00:02:16,000
そしてそこに私たちはそれを持っています。

31
00:02:16,260 --> 00:02:22,350
私はAとBのような変数名を渡してAとBを等しくすることもできました。

32
00:02:22,890 --> 00:02:23,970
&nbsp;

33
00:02:24,210 --> 00:02:25,650
それはまったく同じことです。

34
00:02:25,650 --> 00:02:30,640
それで、あなたが最初のもののためにそれを使用するとき、それが正しい順序であることを確認しなければなりません。

35
00:02:30,960 --> 00:02:35,550
次のネストされたリストでは、単語Helloを取得するためにインデックスを使用しています。

36
00:02:35,790 --> 00:02:36,670
これはかなりトリッキーです。

37
00:02:36,690 --> 00:02:42,770
だからあなたはこれであなたの時間をとり、内側から外側に向かって始めるでしょう。

38
00:02:42,870 --> 00:02:44,620
ここで私たちはこんにちはを見ることができます。

39
00:02:44,700 --> 00:02:50,100
&nbsp;

40
00:02:50,280 --> 00:02:56,820
それはリストであり、木星であり、それは一番上のリストの内側にある別のリストの内側にあるリストの中にある、それを強調するブラケットであなたを助けます。

41
00:02:57,330 --> 00:03:06,730
だから、ここの全体のリストは、私たちが最初につかみたいもので、インデックス3 0 1 2 3に位置付けようとしています。

42
00:03:07,140 --> 00:03:09,210
私たちは先に進み、それをつかむでしょう。

43
00:03:09,510 --> 00:03:15,930
これで私はこのリストを手に入れました。私のターゲットとなる単語helloを持つリストがリストの2番目の項目であることがわかります。

44
00:03:15,930 --> 00:03:19,790
&nbsp;

45
00:03:20,550 --> 00:03:24,240
そして今、私はこれをもう一度打ち破り、0 1

46
00:03:27,150 --> 00:03:29,540
2としてから、私は1つの要素のリストを持っています。

47
00:03:29,540 --> 00:03:32,170
だから私は先に進んで、再びゼロを得ることができます。

48
00:03:32,610 --> 00:03:35,090
そして最後に、私は文字列のこんにちはOKを持っています。

49
00:03:35,100 --> 00:03:39,660
これは非常に扱いにくいものであり、実際にはこのような状況は決してありません。

50
00:03:39,810 --> 00:03:44,190
しかし、私がパンダを使って作業する場合、あなたは2つのレベルの深いものをしなければならないでしょう。

51
00:03:44,190 --> 00:03:45,940
だから心に留めておいてください。

52
00:03:46,440 --> 00:03:46,780
大丈夫。

53
00:03:46,800 --> 00:03:51,090
次に、このニースの辞書に「こんにちは」という言葉をつけた次の質問が与えられました。

54
00:03:51,420 --> 00:03:53,820
これは厄介なスラッシュトリッキーになるように準備してください。

55
00:03:53,820 --> 00:03:55,410
だからこれはかなりトリッキーです。

56
00:03:55,710 --> 00:03:57,810
しかし、進んで段階的にそれを分解しましょう。

57
00:03:57,840 --> 00:04:01,190
あなたがしなければならない最初のことは、キーをつかむことです。

58
00:04:01,200 --> 00:04:05,410
だから私たちを見れば、実際には鍵そのものを呼び出すことができます。

59
00:04:05,640 --> 00:04:11,460
私たちは実際には、最も外側の辞書に1つのキーしか持っていません。

60
00:04:13,530 --> 00:04:19,230
そして今、私はいくつかの要素のリストを持っていて、ここでこの辞書を手に入れたいと気づきました。それは0 1 2

61
00:04:19,230 --> 00:04:22,270
3です。

62
00:04:22,270 --> 00:04:25,410
したがって、そのリストのインデックス3。

63
00:04:25,410 --> 00:04:31,920
だから、私たちは、リストのインデックスを辞書のキー値ペアとミックスしているのです。

64
00:04:32,400 --> 00:04:36,810
そして、私はもう一度辞書を持っているので、キーの値を取得したい。

65
00:04:36,810 --> 00:04:39,260
トリッキー。

66
00:04:40,020 --> 00:04:46,520
それから私はリストをもう一度持っていて、私は0 1 2 3であるこの辞書をつかみたい。

67
00:04:47,810 --> 00:04:52,240
そして、私は再び辞書を持っています。私は重要な目標をつかみたいのです。

68
00:04:52,770 --> 00:04:59,210
最後にリストがあり、最後の要素0 1 2 3を取りたいと思います。

69
00:05:00,000 --> 00:05:01,390
それはこんにちは。

70
00:05:01,750 --> 00:05:02,130
OK。

71
00:05:02,130 --> 00:05:04,390
かなり難しい。

72
00:05:04,410 --> 00:05:09,520
それは非常に迷惑なので、あなたがすぐにこれを把握することができなかった場合はあまりにも心配しないでください。

73
00:05:09,560 --> 00:05:15,250
トリッキーですが、実際にはこのソリューションのロジックを実際に理解することができれば幸いです。

74
00:05:15,270 --> 00:05:18,210
次の質問は、タプルとリストの主な違いは何ですか？

75
00:05:18,270 --> 00:05:21,450
よくタプルは不変であり、リストは変更可能です。

76
00:05:21,450 --> 00:05:23,980
それは主な違いです。

77
00:05:24,060 --> 00:05:28,500
その後、ドメインドットコムのフォームユーザーの文字列から電子メールWebサイトドメインを取得する関数を作成したかったのです。

78
00:05:28,500 --> 00:05:30,960
&nbsp;

79
00:05:30,960 --> 00:05:36,610
たとえば、ユーザーをドメインcomに渡すと、ドメインドットコムが返されます。

80
00:05:37,260 --> 00:05:43,120
ドメイン取得と呼ばれる関数を作成しましょう。

81
00:05:43,530 --> 00:05:51,540
それは文字列になる電子メール変数を受け取り、分割した電子メールを返し、シンボルに分割します。

82
00:05:54,230 --> 00:05:56,330
&nbsp;

83
00:05:56,340 --> 00:05:58,900
それがどのように働くか見てみましょう。

84
00:05:58,950 --> 00:06:00,550
私はそれを実行する場合。

85
00:06:01,170 --> 00:06:01,860
大丈夫です。

86
00:06:01,860 --> 00:06:08,900
だから私がちょうどそれを実行すると、私はシンボルでこれを分割してしまい、リストを返す。

87
00:06:09,030 --> 00:06:14,360
私はそのリストに2番目の項目を入れて、その上にインデックス1をつけたいと思っています。

88
00:06:14,430 --> 00:06:16,920
そして、私がこれを実行すると、正しい答えが得られます。

89
00:06:16,950 --> 00:06:20,810
そのドメインドットコム。

90
00:06:20,820 --> 00:06:24,640
次に、真を返す基本的な関数を作成します。

91
00:06:24,740 --> 00:06:27,940
dogという文字列が入力文字列に含まれています。

92
00:06:28,020 --> 00:06:30,910
また、句読点のような端の場合については心配しないでください。

93
00:06:30,920 --> 00:06:37,940
犬という言葉は、大文字化を説明したり、先に進むべきことは関数を作成することです。

94
00:06:37,940 --> 00:06:47,850
4番目のfind

95
00:06:47,850 --> 00:06:57,720
dogは変数を取り込んで変数Sを呼び出し、その後、大文字を説明するためにdogがSにあるかどうかを確認します。

96
00:06:57,720 --> 00:07:03,060
私は先に進んでSのすべてを下げてから、それを分割して実際にオブジェクトのリストに変え、それを実行すると真となります。

97
00:07:03,060 --> 00:07:08,130
&nbsp;

98
00:07:08,280 --> 00:07:09,500
そこに犬がいますか？

99
00:07:09,540 --> 00:07:12,910
私がこの文字列を渡したときに実際に何が起きているのかを見せてください。

100
00:07:12,960 --> 00:07:15,480
私はsが等しいと言うでしょう。

101
00:07:15,570 --> 00:07:18,030
ここに犬がいますか？

102
00:07:19,410 --> 00:07:20,210
を実行します。

103
00:07:20,310 --> 00:07:27,360
&nbsp;

104
00:07:27,360 --> 00:07:34,800
そして、私がエスケープされたより低いと呼ぶなら、私は小文字のすべてを行います。そして、私がエソートされた分裂を言うなら、このリストを得て、ついに私はそのリストの犬です。

105
00:07:34,800 --> 00:07:41,640
だから私は、この1行の文で実行しているステップで、dogという文字列が文字列に含まれる回数を数える関数を作成したいと考えています。

106
00:07:41,640 --> 00:07:45,000
&nbsp;

107
00:07:45,000 --> 00:07:48,570
そして、やはりエッジケースを無視することができます。

108
00:07:49,020 --> 00:07:57,090
私たちは先に進み、FがCount dog

109
00:07:57,090 --> 00:08:03,830
ticksと呼ばれる関数を作成し、tが初期カウントを0に設定すると文字列を作成し、wordを入力して再びs tを言うと言うでしょう。

110
00:08:03,880 --> 00:08:15,390
最後の質問と同じ方法でスプリットを下げてから、その単語が犬と等しい場合はコロンを追加し、カウントに1を加算します。

111
00:08:16,560 --> 00:08:18,610
&nbsp;

112
00:08:18,720 --> 00:08:22,590
つまり、countはcountに1を加えたものに等しいと言います。

113
00:08:22,980 --> 00:08:26,070
だから、countはcountに1を加えたものに等しいとか、またはshorthandと言うことができます。

114
00:08:26,070 --> 00:08:29,690
何人かの人が好むものは、ちょうどプラス1と等しいです。

115
00:08:29,730 --> 00:08:31,880
それはまったく同じことです。

116
00:08:31,890 --> 00:08:34,540
そして最後に私はちょうど最後に戻ります。

117
00:08:34,740 --> 00:08:37,470
私のカウントは、私がその単語の犬を見た回数です。

118
00:08:37,470 --> 00:08:42,850
今私達が前進してこれを実行するなら、ここで正しい答えが得られます。

119
00:08:43,020 --> 00:08:47,670
次に、フィルター関数でラムダ式を使用して、文字Sを開始しない単語をフィルターで除外したいと考えました。

120
00:08:47,670 --> 00:08:49,490
&nbsp;

121
00:08:49,650 --> 00:08:56,460
たとえば、CQはスープにフィルタリングされるべき単語のリストであり、次にサラダに行きましょう。

122
00:08:56,460 --> 00:08:58,650
&nbsp;

123
00:08:58,650 --> 00:09:06,030
私はフィルターを言うつもりだ、そして、私は土地表現を使うようになる。

124
00:09:06,090 --> 00:09:14,100
&nbsp;

125
00:09:14,100 --> 00:09:23,060
それは言葉を取るつもりですし、その単語の文字列の最初の要素がSと等しいかどうかをチェックしてから、シーケンスを渡すことはしませんし、最後にすべてをリストとしてキャストします。

126
00:09:24,060 --> 00:09:25,170
それが答えです。

127
00:09:25,170 --> 00:09:26,480
スープとサラダ。

128
00:09:26,550 --> 00:09:32,280
&nbsp;

129
00:09:32,280 --> 00:09:38,020
したがって、philtreの場合、このラムダ式または関数のために、あなたが渡したプディングはブール値を返す必要があります。そして、これらのブール値に基づいてシーケンスをフィルタリングします。

130
00:09:38,850 --> 00:09:39,150
大丈夫。

131
00:09:39,150 --> 00:09:41,160
ここで私たちは最終的な問題に陥っています。

132
00:09:41,280 --> 00:09:42,650
問題のステートメントはこれです。

133
00:09:42,670 --> 00:09:46,570
あなたは少し速すぎて運転しており、警察官があなたを止めています。

134
00:09:46,620 --> 00:09:50,310
あなたは、3つの可能な結果のうちの1つを返す関数を書く必要があります。

135
00:09:50,310 --> 00:09:53,000
チケットの小さなチケットまたは大きなチケットはありません。

136
00:09:53,190 --> 00:09:56,650
あなたのスピードが60以下であれば、結果はチケットではありません。

137
00:09:56,700 --> 00:10:01,890
速度が61と80の間にある場合結果は小さなチケットです。

138
00:10:01,890 --> 00:10:06,870
&nbsp;

139
00:10:06,870 --> 00:10:12,760
速度が81以上の場合、結果は大きなチケットであり、誕生日の関数のパラメータでブール値としてエンコードされるあなたの誕生日は少なくなります。スピードは5倍高くなる可能性があります。

140
00:10:12,780 --> 00:10:14,120
すべての場合。

141
00:10:14,340 --> 00:10:15,800
あなたの誕生日であれば意味します。

142
00:10:15,810 --> 00:10:22,830
したがって、誕生日の下線が真実であれば、速度制限はあなたのために5マイルまたは5キロも上がります。

143
00:10:22,830 --> 00:10:23,970
&nbsp;

144
00:10:24,420 --> 00:10:26,290
さあ始めましょう。

145
00:10:26,310 --> 00:10:29,840
この過去の声明は削除させていただきます。

146
00:10:29,910 --> 00:10:34,070
私がしたい最初のことは、誰かの誕生日かどうかをチェックし、それに応じて速度を調整することです。

147
00:10:34,080 --> 00:10:37,080
&nbsp;

148
00:10:40,650 --> 00:10:48,500
出生であれば、スピードはスピードマイナス5に等しいと言うでしょう。

149
00:10:49,050 --> 00:10:57,420
スピードはスピードと同じです。次に、チケットの条件をスピードアップすることを検討します。

150
00:10:57,450 --> 00:10:59,590
&nbsp;

151
00:10:59,640 --> 00:11:06,450
だから、再びスピードが80を超えるなら、それは大きなチケットです。

152
00:11:06,510 --> 00:11:11,160
だから私は先に進み、文字列の大きなチケットを返すでしょう。

153
00:11:12,680 --> 00:11:23,820
次に、スピードが60よりも大きい場合は、次に小さいチケットを返すことになります。

154
00:11:26,040 --> 00:11:27,540
&nbsp;

155
00:11:27,570 --> 00:11:32,870
それだけで帰りのチケットになります。

156
00:11:33,120 --> 00:11:34,410
それから、これを実行して実行することができます。

157
00:11:34,410 --> 00:11:40,040
だから、81は通常大きなチケットですが、それはあなたの誕生日なので、それは本当だと言うでしょう。

158
00:11:40,080 --> 00:11:41,700
それは小さなチケットでなければなりません。

159
00:11:41,940 --> 00:11:46,910
そしてそこに私たちはそれを持っています。そして、虚偽の81井戸は間違いなく大きなチケットです。

160
00:11:46,980 --> 00:11:47,840
大丈夫。

161
00:11:47,880 --> 00:11:49,620
あなたがそのソリューションを楽しんでいたらと思っています。

162
00:11:49,620 --> 00:11:54,390
お気軽にQ＆Aフォーラムに質問を投稿してください。お手伝いします。

163
00:11:54,390 --> 00:11:56,220
みんなありがとう、私は次の講演でお会いしましょう
