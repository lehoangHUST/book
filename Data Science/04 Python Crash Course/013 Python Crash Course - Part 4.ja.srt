1
00:00:05,220 --> 00:00:06,050
みなさん、こんにちは。

2
00:00:06,050 --> 00:00:12,060
&nbsp;

3
00:00:12,120 --> 00:00:18,180
&nbsp;

4
00:00:18,180 --> 00:00:19,920
このシリーズの講義では、Pythonのクラッシュコースの講義シリーズ第4部にようこそラムダ式とマップ関数、Pythonのさまざまなデータ型で使用できるさまざまな方法について説明します。

5
00:00:19,920 --> 00:00:23,280
木星ノートブックに戻って始めましょう。

6
00:00:23,280 --> 00:00:23,550
大丈夫。

7
00:00:23,550 --> 00:00:25,130
ここで私は木星ノートブックにいます。

8
00:00:25,170 --> 00:00:30,870
最後に、Pythonで独自の関数を作成する方法を議論したところで、マップ関数とフィルタ関数について議論し、次に完全な関数を書く代わりにラムダ式を使用する方法について説明します。

9
00:00:30,870 --> 00:00:36,540
&nbsp;

10
00:00:36,540 --> 00:00:38,690
&nbsp;

11
00:00:38,730 --> 00:00:44,210
私は先に進んで、キーワードDを死に使用した関数を書く方法をすぐに見直しましょう。

12
00:00:44,400 --> 00:00:51,300
この場合の関数名は、この関数を引数としていくつかの変数を受け入れる時間を呼び出します。

13
00:00:51,300 --> 00:00:53,360
彼らです。

14
00:00:53,360 --> 00:00:57,930
そして、私はその変数に2を掛けた値を返します。

15
00:00:58,440 --> 00:01:03,390
つまり、5などの数字で2の時間を呼び出すと、10を返します。

16
00:01:03,390 --> 00:01:07,760
さあ、マップ関数について説明しましょう。

17
00:01:08,370 --> 00:01:12,160
私はCQと呼ばれるシーケンスを作るつもりです、そしてそれはリストになるでしょう。

18
00:01:12,180 --> 00:01:14,970
1 2 3 4 5。

19
00:01:15,030 --> 00:01:23,400
さて、実際にこの関数の時間をこのリストのすべての要素に適用して、リストを出力したいとしましょう。

20
00:01:23,520 --> 00:01:25,070
&nbsp;

21
00:01:25,290 --> 00:01:31,380
さて、forループを使ってそれを行い、別のリストに結果を追加することができます。

22
00:01:31,410 --> 00:01:37,960
ただし、mapはPythonの組み込み関数で、そのステップを保存することができます。

23
00:01:37,960 --> 00:01:39,390
あなたは先に進み、数学を入力しますか？

24
00:01:39,420 --> 00:01:44,280
実際にマップのドキュメント文字列を表示するには、shiftを入力します。

25
00:01:44,340 --> 00:01:49,340
しかし、基本的にiteratorを作成して、各iterableの引数を使って関数を計算します。

26
00:01:49,340 --> 00:01:50,250
&nbsp;

27
00:01:50,520 --> 00:01:54,890
私が行こうとすると、実際に何を意味するのか、ちょっとした単純な英語で説明してください。

28
00:01:54,990 --> 00:02:02,170
あなたはmap pasanに例えば2の時間の関数を言うとしよう。

29
00:02:02,340 --> 00:02:06,000
次に、その関数をマップするシーケンスを指定します。

30
00:02:06,150 --> 00:02:12,200
そして、あなたがそれを実行すると、彼らはあなたがメモリ内のこの特定の場所に地図を持っていることを報告します。

31
00:02:12,210 --> 00:02:19,050
実際にこのマップを実行し、結果をリストとして戻す場合は、組み込みリスト関数を使用してリストにキャストします。

32
00:02:19,080 --> 00:02:21,590
&nbsp;

33
00:02:21,960 --> 00:02:28,890
そして、これは最終的に、このシーケンス内のすべての要素にマップされたこの関数を返し、それをリストとして返します。

34
00:02:28,890 --> 00:02:30,490
&nbsp;

35
00:02:30,510 --> 00:02:34,130
そして今、私たちはすべての要素に2を掛けたことが分かります。

36
00:02:34,140 --> 00:02:39,760
だから今、私たちは1つ2つ3つ4つ5つの代わりに2つの4つの6つの10を持っています。

37
00:02:40,250 --> 00:02:41,220
OK。

38
00:02:41,220 --> 00:02:48,150
だから、あなたは時間2のような完全な関数を完全に定義しなければならないのか、それとも簡単な方法があるのだろうかと疑問に思うかもしれません。

39
00:02:48,180 --> 00:02:49,610
&nbsp;

40
00:02:49,620 --> 00:02:54,480
通常、マップのようなものを使用しているときは、実際に関数全体を記述して定義したくないからです。

41
00:02:54,480 --> 00:02:55,650
&nbsp;

42
00:02:55,770 --> 00:03:01,980
これはおそらく一度だけのことであり、それが土地表現が生まれる場所です。

43
00:03:02,040 --> 00:03:09,590
この関数をラムダ式に書き直す方法を説明し、ゆっくりと分解してみましょう。

44
00:03:09,590 --> 00:03:11,930
&nbsp;

45
00:03:12,360 --> 00:03:21,880
この関数の時間も実際には、コロンがr時間2を返すように、実際には1行に書くことができます。

46
00:03:21,890 --> 00:03:23,190
&nbsp;

47
00:03:23,250 --> 00:03:28,010
そして、私はこれらの2つの細胞を再び実行する場合、それはまだうまく動作します。

48
00:03:28,050 --> 00:03:34,380
土地表現は、デフォルトでは不要な単語を削除することを除いて、この種の構造を複製しようとします。

49
00:03:34,980 --> 00:03:37,180
&nbsp;

50
00:03:37,320 --> 00:03:42,150
あなたがそれについて考えているとき、それらは関数の中でちょうど与えられた値であるため、実際にはFやリターンは必要ありません。

51
00:03:42,150 --> 00:03:44,100
&nbsp;

52
00:03:44,130 --> 00:03:48,530
それを定義し、土地表現のためにそれを返さなければなりません。

53
00:03:48,570 --> 00:03:50,730
そうでない場合は、匿名関数として知られています。

54
00:03:50,730 --> 00:03:55,200
&nbsp;

55
00:03:55,200 --> 00:04:00,470
あなたはラムダ式である関数全体を定義する必要がなく、この関数を本質的に読み出すことでそれを行うことができるようにするインスタンスで置き換えたいだけです。

56
00:04:00,480 --> 00:04:08,130
しかし、Fと名前を取り除き、代わりにラムダを入力するだけで、あなたは先に進んで戻り値を取り除き、実際に何を返すかをタイプするだけです。

57
00:04:08,130 --> 00:04:12,320
&nbsp;

58
00:04:12,570 --> 00:04:15,970
そして、これは表現の土地です。

59
00:04:16,020 --> 00:04:23,490
今、私はtがこの土地と等しいと言って、式のようにして、6などのいくつかの番号のtを呼びたいと思っていました。

60
00:04:23,520 --> 00:04:25,060
&nbsp;

61
00:04:25,260 --> 00:04:28,490
そして私は、私が2回6回返すことがわかります。

62
00:04:28,590 --> 00:04:32,970
だから私は通常、このような土地表現を使わないだろうが、それを使うことは可能である。

63
00:04:33,330 --> 00:04:39,060
まあ、ラムダ式を使うのはmapのようなものか、関数全体を定義する必要がないということです。

64
00:04:39,060 --> 00:04:40,320
&nbsp;

65
00:04:40,500 --> 00:04:49,060
ラムダ式をここに入力すると、ラムダを実際にコロンをパーザーしたいものとし、この場合に戻ってきたいものは先に進み、すべてを3倍します。

66
00:04:49,300 --> 00:04:55,400
&nbsp;

67
00:04:55,450 --> 00:05:01,240
これを同じシーケンスで実行すると、シーケンス内のすべての要素を取得し、3つを掛けて、関数全体を正式に定義する必要がなくなりました。

68
00:05:01,240 --> 00:05:06,310
&nbsp;

69
00:05:06,370 --> 00:05:11,500
ラムダ式のラムダ式などを使用するだけで、特にPandursライブラリの学習を始めるときにたくさん使うことができます。

70
00:05:11,510 --> 00:05:13,980
&nbsp;

71
00:05:13,990 --> 00:05:18,330
あなたがこれに関する質問があればQ＆Aフォーラムを投稿してください。

72
00:05:18,340 --> 00:05:25,130
しかし、基本的には、関数全体をクリーンなコードの1行に書き直す方法です。

73
00:05:25,330 --> 00:05:30,720
これは、通常、関数全体を記述して定義する必要がないためです。

74
00:05:31,150 --> 00:05:35,620
しかし、それはあなたが土地表現で混乱している場合は、常にあなたのためのオプションです。

75
00:05:35,620 --> 00:05:40,630
私たちが2回目と同じように正式な関数を定義し、その代わりに使用することができます。

76
00:05:40,620 --> 00:05:44,800
さあ、組み込みフィルタ関数について説明しましょう。

77
00:05:44,800 --> 00:05:48,010
フィルターは、マップするのに非常に似た構造を持っています。

78
00:05:48,120 --> 00:05:54,490
しかし、関数をシーケンス内のすべての要素にマッピングする代わりに、シーケンスから要素を除外します。

79
00:05:54,490 --> 00:05:55,570
&nbsp;

80
00:05:55,570 --> 00:05:59,800
私が行こうとすると、これを行う方法をあなたに教えてください。

81
00:05:59,890 --> 00:06:09,190
あなたは先に進み、filterを呼び出して、フィルタリングしてブール値を返す関数またはラムダ式のいずれかをパーザに渡します。

82
00:06:09,640 --> 00:06:13,460
&nbsp;

83
00:06:13,480 --> 00:06:27,070
したがって、例えば、数字のコロンのラムダは、数が2に等しいことを意味し、次にシーケンスを渡すことができます。

84
00:06:27,070 --> 00:06:28,490
&nbsp;

85
00:06:28,870 --> 00:06:31,530
そして、これはフィルタ式だけを返します。

86
00:06:31,560 --> 00:06:34,100
実際に私は結果を戻したい。

87
00:06:34,300 --> 00:06:36,230
私はそれをリストにキャストする必要があります。

88
00:06:36,730 --> 00:06:43,030
そして、これは私のシーケンス2と4に偶数だけ戻します。

89
00:06:43,030 --> 00:06:45,400
ここで実際に起こっていることを解説しましょう。

90
00:06:45,610 --> 00:06:54,070
私はフィルターを言って、このラムダ式は数値を取り、ある種の条件付き演算に基づいて条件付き真または偽の値を返します。

91
00:06:54,160 --> 00:06:56,950
&nbsp;

92
00:06:57,000 --> 00:07:02,930
だから、フィルタはある種類の関数やブール値を返すラムダ式を使用していなければなりません。

93
00:07:02,950 --> 00:07:04,520
正しいか間違っているか。

94
00:07:04,630 --> 00:07:08,680
そして、あなたが先に進むべきことは、反復可能なオブジェクトに渡すことです。

95
00:07:08,680 --> 00:07:14,350
そして、あなたがそのリストを呼び出すと、このステートメントが真実であったところの値だけが返されます。

96
00:07:14,650 --> 00:07:18,390
この場合、偶数の場合は除外しました。

97
00:07:18,400 --> 00:07:19,300
大丈夫。

98
00:07:19,300 --> 00:07:22,170
では、方法について説明しましょう。

99
00:07:22,210 --> 00:07:28,450
メソッドは基本的に、オブジェクトに影響を与えるオブジェクトを作成したり、何らかの形で結果を返すことができます。

100
00:07:28,570 --> 00:07:30,480
&nbsp;

101
00:07:30,490 --> 00:07:32,670
私が先に進んで、私が何を意味するかを見せてください。

102
00:07:32,750 --> 00:07:37,720
私はSと呼ばれる文字列を作るつもりで、これは何かのように言うでしょう。

103
00:07:38,380 --> 00:07:42,550
こんにちは私の名前は大都市です。 Am。

104
00:07:42,580 --> 00:07:51,970
Sam私はsと点を呼び出すことができ、タブと木星のノートブックをクリックすると、利用可能なすべての鞭のタブの結果が表示されます。

105
00:07:51,970 --> 00:07:54,340
&nbsp;

106
00:07:54,340 --> 00:07:55,470
下へスクロール。

107
00:07:55,480 --> 00:08:00,040
この文字列オブジェクトのすべての利用可能なメソッドの結果を取得します。

108
00:08:00,040 --> 00:08:04,300
今、私たちはこれらすべてを乗り越える時間がありません。これらのすべてがコースを通して使用されることはありません。私たちはそれらのかなりの部分を使用します。

109
00:08:04,300 --> 00:08:06,080
&nbsp;

110
00:08:06,100 --> 00:08:08,610
重要なものを見せてもらう。

111
00:08:09,160 --> 00:08:14,120
文字列内の各文字を小文字にすると小文字になります。

112
00:08:14,230 --> 00:08:16,790
また、かっこを閉じる必要があることに注意してください。

113
00:08:17,050 --> 00:08:22,390
あなたがこのように低い電話をかけるか、戻ってきて、ああ、あなたは機能が低いことを尋ねています。

114
00:08:22,380 --> 00:08:27,430
前に述べたように、逆のことをしたいのであれば、それらの括弧を閉じて実際に実行しなければなりません。

115
00:08:27,430 --> 00:08:28,310
&nbsp;

116
00:08:28,330 --> 00:08:33,060
このケースでは大文字であなたが呼ぶことができるものはすべて思いついたものです。

117
00:08:34,310 --> 00:08:42,210
もう一つの便利な関数やメソッドは、文字列のために私を許しているsplitメソッドです。splitメソッドは、デフォルトでは、その文字列のすべての空白に文字列を分割します。

118
00:08:42,250 --> 00:08:48,360
&nbsp;

119
00:08:48,370 --> 00:08:50,860
だから私たちはこんにちは私の名前はサムです。

120
00:08:50,860 --> 00:08:55,240
私たちがエスケープされた分割を言うとき、これをすべての空白で分割します。

121
00:08:55,240 --> 00:08:59,340
これは、このコースの後半でテキスト解析に本当に便利になるでしょう。

122
00:08:59,350 --> 00:09:01,370
私に入って例を示しましょう。

123
00:09:01,380 --> 00:09:04,590
私たちのようなものを言うツイートがあるとしましょう。

124
00:09:04,890 --> 00:09:10,150
Goスポーツのハッシュタグスポーツ。

125
00:09:10,520 --> 00:09:19,290
私たちがツイートの考えを分割すると、これは空白に基づいてテキストをリストに分割します。

126
00:09:19,450 --> 00:09:26,530
しかし実際には、特定の要素や文字を分割するために文字列を分割して渡すことができます。

127
00:09:26,710 --> 00:09:33,360
ハッシュタグを渡してこれを実行すると、文字列が分割され、ハッシュタグが見つかると、メッセージがあり、最後にハッシュタグが付きます。

128
00:09:33,370 --> 00:09:36,230
&nbsp;

129
00:09:36,550 --> 00:09:39,220
そして、実際にはリストを返しますが、そのインデックスは可能です。

130
00:09:39,220 --> 00:09:46,530
だから、私がちょうどハッシュタグをつかみたいのであれば、大括弧1つとすべてのスポーツを返すことができるので、いくつかのツイート文字列からハッシュタグを取得したい場合に、これがどのように役立つかを既に見ることができます。

131
00:09:46,540 --> 00:09:51,450
&nbsp;

132
00:09:51,760 --> 00:09:52,780
OK。

133
00:09:52,780 --> 00:09:56,710
これらは、Eストリングの上下端分割のための便利なメソッドです。

134
00:09:56,710 --> 00:09:57,200
それらは良いものです。

135
00:09:57,250 --> 00:09:59,620
それらは私達がコースを通して使用するつもりです。

136
00:10:00,910 --> 00:10:03,040
辞書でできることを教えてください。

137
00:10:03,250 --> 00:10:04,690
だから、辞書を覚えている。

138
00:10:04,730 --> 00:10:06,860
私たちに古いものがあるかどうか調べてみましょう。

139
00:10:07,180 --> 00:10:15,780
さて、これをK-1に1の値で再割り当てします。

140
00:10:15,880 --> 00:10:20,800
そして、ケイト2は2という値の鍵だと言うでしょう。

141
00:10:20,800 --> 00:10:21,440
大丈夫。

142
00:10:21,700 --> 00:10:22,580
ここに私の辞書があります。

143
00:10:22,600 --> 00:10:24,920
K. 1つはk = 2です。

144
00:10:24,940 --> 00:10:30,510
これで、dドットと言うことができ、タブをクリックすると、利用可能なさまざまな方法を見ることができます。

145
00:10:30,700 --> 00:10:38,140
いくつかの便利なメソッドはキーメソッドです。これはキーを辞書に返します。

146
00:10:38,140 --> 00:10:47,710
項目を尋ねると、これは辞書項目を返します。次に、私たちが辞書項目を参照するかどうかを尋ねることもできます。

147
00:10:47,710 --> 00:10:48,870
&nbsp;

148
00:10:49,060 --> 00:10:53,670
ポップ、ゲット、または値を言うことができます。

149
00:10:53,830 --> 00:10:55,680
だから、辞書の値がほしいならば。

150
00:10:55,720 --> 00:10:57,430
これは値を返します。

151
00:10:57,430 --> 00:10:59,810
辞書は命令を保持しないことを覚えておいてください。

152
00:11:00,040 --> 00:11:04,690
コースのキー項目や値は実際には使用しませんが、リストのいくつかの便利な方法を理解していただきたいと思います。

153
00:11:05,660 --> 00:11:07,500
&nbsp;

154
00:11:07,510 --> 00:11:08,740
私はリストを作るために外出するつもりです。

155
00:11:08,750 --> 00:11:10,530
Ls t。

156
00:11:10,540 --> 00:11:12,680
1から3と言ってください。

157
00:11:12,820 --> 00:11:20,920
ポップアップを呼び出すことでリストから項目をポップすることができます。これはポップしてリストの最後の項目を返します。

158
00:11:21,460 --> 00:11:24,510
&nbsp;

159
00:11:24,820 --> 00:11:36,250
つまり、リストが1つ2つ3つ4つ5つであると言うと、itemはls t

160
00:11:36,710 --> 00:11:44,730
popと等しく、そのリストの最後のアイテムがポップされ、そのアイテムを呼び出すとそれが再割り当てされます。

161
00:11:44,800 --> 00:11:53,440
5はpopというリストであって、実際にpopメソッドを使ってポップ・オフするためのインデックス値を渡すことができるアイテムです。

162
00:11:53,440 --> 00:11:54,730
&nbsp;

163
00:11:54,730 --> 00:12:01,150
あなたが最初にLS T-top pop 0と等しいと言うなら、これを実行してください。

164
00:12:01,150 --> 00:12:02,870
LS Tを見てみましょう。

165
00:12:02,950 --> 00:12:11,100
インデックス0はポップオフされ、最初の変数は最初の要素でした。

166
00:12:11,320 --> 00:12:14,270
だからポップは本当に便利なメソッドなので、追加されます。

167
00:12:14,290 --> 00:12:15,860
しかし、実際にはすでに見てきました。

168
00:12:16,090 --> 00:12:22,620
これで、リストの最後に新しい項目を追加することができます。

169
00:12:23,050 --> 00:12:23,720
大丈夫。

170
00:12:24,010 --> 00:12:29,560
最後に、私があなたに見せたい事柄は、in演算子です。

171
00:12:29,560 --> 00:12:36,140
だから、何かがリストの中にあるかどうかをチェックしたいのであれば、あなたはチェックしたいものと次にリストの中にあるものを言うことができます。

172
00:12:36,140 --> 00:12:39,500
&nbsp;

173
00:12:39,610 --> 00:12:54,100
したがって、trueを返すx yとzを含むリストでfalseとxを返す1〜3のX。

174
00:12:54,100 --> 00:12:58,900
そして最後に、このPythonクラッシュコースの最後のことは、タプルを展開するタプルを解くことです。これは本当にすっきりした機能であり、どのように動作するかを説明します。

175
00:12:59,410 --> 00:13:03,370
&nbsp;

176
00:13:03,370 --> 00:13:11,270
あなたがタプルのリストを含む変数xを持っているとしましょう。

177
00:13:12,010 --> 00:13:19,740
私たちは1つ2つ3つ4つと5つ6つを持っています。

178
00:13:19,750 --> 00:13:29,140
だからここでXを見るとXの最初のアイテムは1と2のタプルで、実際にそのタプルのアイテムをつかむことができるので、私は1つをつかむか2つをつかむことができます。

179
00:13:29,140 --> 00:13:33,040
&nbsp;

180
00:13:33,130 --> 00:13:38,410
私はタプルのアンパックと呼ばれることを行うこともできます。タプルのリストを反復するときにはうまくいくはずです。

181
00:13:38,410 --> 00:13:40,030
&nbsp;

182
00:13:40,030 --> 00:13:45,910
この種のタプルのリストの作成は、Pythonでは本当に一般的です。多くの関数がこの形式で結果を返します。

183
00:13:45,910 --> 00:13:47,550
&nbsp;

184
00:13:47,830 --> 00:14:00,230
それで、我々はタプルと梱包をオプションとして持っているので、Xプリントアイテムのアイテムについて言うことができます。

185
00:14:00,520 --> 00:14:07,300
&nbsp;

186
00:14:07,390 --> 00:14:18,280
そして私がそれを実行すると、それは先に進んで、私のタプルをすべて出力します。そして、パッキングは、実際にこれらのタプルを展開して、私が一緒に行くようにするので、Xの中のコンマBのためにこれを行うことができます。

187
00:14:18,640 --> 00:14:21,950
これで1 3 5が印刷されます。

188
00:14:22,850 --> 00:14:24,830
私はプリンスB.

189
00:14:24,840 --> 00:14:27,250
これにより、これらのタプルの2番目の項目が印刷されます。

190
00:14:27,310 --> 00:14:30,490
2 4 6それはタプルとパッキングです。

191
00:14:30,490 --> 00:14:35,830
あるいは、単に項目を言うのではなく、実際にループの中でこのタプルを展開してください。

192
00:14:35,830 --> 00:14:36,130
&nbsp;

193
00:14:36,140 --> 00:14:40,630
これを取り巻くこれらのかっこは、実際は単なる形式であることに注意してください。

194
00:14:40,630 --> 00:14:43,930
これは、現実の世界で常にタプルをパッキングする方法です。

195
00:14:43,930 --> 00:14:49,840
あなたはタプルとその内部のタプルのいくつかのiterableですXでのパッキングのために表示されます。

196
00:14:50,140 --> 00:14:57,730
そして、あなたはそのタプルの中の個々のアイテムを印刷することができます。それだけでもすべてのことができます。

197
00:14:57,730 --> 00:14:58,210
&nbsp;

198
00:14:58,500 --> 00:15:02,590
このコースの後半で再びタプルとパッキングを思い出してくれます。

199
00:15:02,590 --> 00:15:07,570
&nbsp;

200
00:15:07,690 --> 00:15:13,990
今のところそれほど時間がかかりませんが、もしこれがどれほど難しいと思われても、まったく馴染みのないPythonの一般的な概観で十分です。

201
00:15:13,990 --> 00:15:15,700
&nbsp;

202
00:15:15,700 --> 00:15:21,730
このコースはあまりに進んでいるかもしれませんし、私の完全なPythonブートキャンプコースのような初心者向けのコースが必要かもしれません。

203
00:15:21,860 --> 00:15:25,420
&nbsp;

204
00:15:25,510 --> 00:15:31,000
Kewauneeのフォーラムに質問を投稿してください。次回は、このpythonクラッシュコースのトピックシリーズであなたの知識をテストするための練習です。

205
00:15:31,000 --> 00:15:35,070
&nbsp;

206
00:15:35,080 --> 00:15:36,970
みんなありがとう、私は次の講演で見ます
