1
00:00:05,280 --> 00:00:09,960
&nbsp;

2
00:00:09,960 --> 00:00:15,530
皆さんこんにちは皆さん、この講義のパンダ講義でグループに参加して歓迎します。この方法でグループを使ってデータのグループ行をまとめて集約関数を呼び出す方法を説明します。

3
00:00:15,540 --> 00:00:20,850
私たちが実際に木星のノートブックに飛び込む前に、あなたが後遺症の経験がない場合、あるいはすべての経験やほとんどの人がGROUP

4
00:00:20,850 --> 00:00:25,950
BY声明が実際に何をしているかをよく知っている場合に、

5
00:00:25,950 --> 00:00:28,300
&nbsp;

6
00:00:28,560 --> 00:00:34,890
単純にグループ化すると、列に基づいて行をまとめてグループ化し、その上で何らかの集約関数を実行することができます。

7
00:00:34,890 --> 00:00:36,840
&nbsp;

8
00:00:37,080 --> 00:00:43,390
例えば、この例では、IDSの1つ2つと3つの3つのパーティションがあります。

9
00:00:43,470 --> 00:00:50,220
&nbsp;

10
00:00:50,220 --> 00:00:56,130
&nbsp;

11
00:00:56,130 --> 00:01:03,060
&nbsp;

12
00:01:03,330 --> 00:01:07,680
そして、ID列でグループ化して、あらゆる関数で集計関数を使用して集計できるいくつかの値があります。基本的には、多くの値をとり、多くの値をとり、単一の値を吐き出す一群の値を取って結果を出力したり、平均値や標準偏差などを取るなど

13
00:01:07,800 --> 00:01:13,950
これらはすべて集合関数であり、それはすべてのグループ化メソッドで、グループ化する列を選択できるようにします。

14
00:01:13,950 --> 00:01:14,950
その列の値に基づいて、すべての行をまとめて収集します。

15
00:01:15,000 --> 00:01:18,250
そして、あなたはそれにある種の集約関数を実行します。

16
00:01:18,440 --> 00:01:21,330
大丈夫。

17
00:01:21,360 --> 00:01:22,160
しかし、それは先に進み、パンダでGROUP BYを使用する方法を学びましょう。

18
00:01:22,200 --> 00:01:25,980
私は先に進み、木星ノートにジャンプします。

19
00:01:26,010 --> 00:01:28,820
さて、ここでは木星のノートにいます。

20
00:01:28,860 --> 00:01:31,390
私は先に進み、このデータ行をコピーして貼り付けました。

21
00:01:31,530 --> 00:01:34,650
&nbsp;

22
00:01:34,660 --> 00:01:40,350
これは基本的にノートブックからの単なる辞書であり、このノートブックは単にpandasフォルダの1つによって呼び出されます。

23
00:01:40,350 --> 00:01:41,710
&nbsp;

24
00:01:41,760 --> 00:01:47,750
これを手動で入力することもできますが、このデータを辞書だけコピーして、PDデータフレームとし、そのデータ辞書を渡して自動的にデータフレームを作成する必要がありますそれはこのように見える。

25
00:01:47,780 --> 00:01:54,780
&nbsp;

26
00:01:54,780 --> 00:01:58,040
基本的にこれは単なるデータです。

27
00:01:58,050 --> 00:01:59,900
私たちは3つの会社コードを持つ会社の列を持っています。

28
00:02:00,000 --> 00:02:03,170
GoogleのMicrosoftとFacebook。

29
00:02:03,330 --> 00:02:05,390
今私達はそれの中に独特の人々の束を持つ人の列を持っています。

30
00:02:05,520 --> 00:02:08,750
そして、我々はいくつかの販売番号200 120などを持っています。

31
00:02:08,910 --> 00:02:13,460
&nbsp;

32
00:02:13,590 --> 00:02:19,020
今私たちが行うことができるのは、そのグループのメソッドを使って列名に基づいて行をグループ化することです。たとえば、私が進んでZFと呼ぶ会社でグループ化してから、このケースでグループ化する列を渡します。

33
00:02:19,020 --> 00:02:25,950
私は会社のコラムでグループを作りたいと思っています。

34
00:02:25,950 --> 00:02:32,070
オブジェクトごとにグループを取得し、メモリに格納されている場所を指し示します。

35
00:02:32,070 --> 00:02:38,240
私ができることは新しい変数としてこれを保存することです。私は私の会社に来るようなものを言うことができ、私はこのグループをオブジェクトごとに持っています。

36
00:02:38,400 --> 00:02:43,100
&nbsp;

37
00:02:43,350 --> 00:02:51,750
その後、Group Byを使用する2番目の手順。

38
00:02:51,750 --> 00:02:55,290
その列でグループ化した後は、何らかの集約関数を呼び出すことになります。

39
00:02:55,290 --> 00:02:58,250
&nbsp;

40
00:02:58,250 --> 00:03:03,090
たとえば、私が会社の平均を取得したいのであれば、それは販売コラムを見て、私にその会社の平均または平均売上を与えます。

41
00:03:03,420 --> 00:03:10,320
&nbsp;

42
00:03:10,320 --> 00:03:13,310
&nbsp;

43
00:03:13,320 --> 00:03:18,180
なぜなら、これらが文字列であり、単に文字列の平均をとることができず、その結果、パンダラーは、非数値列であるものを自動的に無視するだけだからです。

44
00:03:18,180 --> 00:03:23,490
同様に、会社ごとの売上まですべての機能を実行することができます。

45
00:03:23,610 --> 00:03:26,060
&nbsp;

46
00:03:26,070 --> 00:03:32,520
Vesteyなどの標準偏差を行うことさえできます 私が戻ってくるものは、Companyというインデックスとsalesのカラム値を持つ実際のデータフレームです。

47
00:03:32,520 --> 00:03:33,760
&nbsp;

48
00:03:33,990 --> 00:03:42,900
B.

49
00:03:42,900 --> 00:03:48,760
それで、インデックス提供などのことができることを意味するので、私が言うことができるように会社のすべての売り上げを合計して、会社の売上の一部を計上してから、ドットellos

50
00:03:49,110 --> 00:03:55,920
C F

51
00:03:55,920 --> 00:04:02,430
そして、それは私にFacebookの売り上げのいくつかを与えています。あなたがやろうとしていることは、実際に変数としてこのグループをオブジェクトで設定しているわけではありません。

52
00:04:02,850 --> 00:04:06,440
&nbsp;

53
00:04:07,000 --> 00:04:13,600
おそらくこれをすべて1行で呼び出すだけです。

54
00:04:13,710 --> 00:04:17,510
あなたがパンツレスで本当に快適になったら、彼らは団体のようなものを言うでしょうし、いくつかのようなものを呼び出します。

55
00:04:17,550 --> 00:04:19,670
&nbsp;

56
00:04:19,710 --> 00:04:25,140
そして、あなたがFacebookのためだけにそれを望むなら、あなたはFBIと呼んでおり、それはまったく同じことです。

57
00:04:25,830 --> 00:04:27,920
&nbsp;

58
00:04:28,110 --> 00:04:35,160
あなたがやっている可能性のある他の有用な集約関数は、インスタンス数や列の数を数えるだけのものです。

59
00:04:35,160 --> 00:04:36,420
&nbsp;

60
00:04:36,660 --> 00:04:41,850
この場合、人の列は、その列または会社で発生した人のインスタンス数を数えることができるため、返すことができました。

61
00:04:41,850 --> 00:04:44,570
&nbsp;

62
00:04:44,730 --> 00:04:49,890
だから私たちには2人の人がいて、それぞれ2人の売り上げがあり、それは理にかなっています。

63
00:04:49,890 --> 00:04:53,420
最大値や最小値などの操作を行うこともできます。

64
00:04:53,430 --> 00:04:57,360
また、Pythonはアルファベット順に物を格納することができ、基本的にはここに表示しようとしているからです。

65
00:04:57,360 --> 00:05:00,190
&nbsp;

66
00:05:00,960 --> 00:05:07,080
最大値はアルファベットの最後に向かって最新です。アルファベットのCとCの中で最も早いものを呼び出すと、ここに代理店があります。

67
00:05:07,080 --> 00:05:09,410
&nbsp;

68
00:05:09,480 --> 00:05:17,220
しかし、文字列でminまたはmaxを使用しないでください。

69
00:05:17,220 --> 00:05:19,570
あなたはおそらく、これらの怒っているすべての機能を実際には数字の列で使用します。

70
00:05:19,800 --> 00:05:23,310
&nbsp;

71
00:05:23,310 --> 00:05:27,320
私がグループバイについてあなたに示したい最後の便利なことは、説明された方法でGROUP

72
00:05:27,330 --> 00:05:34,440
BYを使用することができ、すぐに有用な情報をまとめてくれます。それからスクライブを言うと、それはあなたに情報の束を与えるでしょう。

73
00:05:35,160 --> 00:05:42,010
例えば、標準偏差の平均値、男性と最大値、各社のコアタイル値を数えます。

74
00:05:42,030 --> 00:05:47,730
&nbsp;

75
00:05:47,730 --> 00:05:53,230
そして、もしあなたがこのフォーマットを気に入らなければ、実際にこれを転置することができるので、各社を実際のインデックスの代わりにカラムにすることを好むなら、転置のようなことを言うことができます。

76
00:05:53,250 --> 00:05:55,060
&nbsp;

77
00:05:55,170 --> 00:05:59,490
&nbsp;

78
00:06:00,060 --> 00:06:08,330
どのような書式であっても、それを記述することができれば、実際には列名を呼び出すことができます。

79
00:06:08,520 --> 00:06:13,530
単一の会社または単一の列に興味があるだけの方。

80
00:06:13,530 --> 00:06:14,260
それは本当にグループのためのものです。

81
00:06:14,280 --> 00:06:18,780
それはかなり基本的です。

82
00:06:18,840 --> 00:06:21,150
グループ化する列でグループ化されたDoppというデータフレームを呼び出し、列の値を単一の値に集計する集約方法を呼び出します。

83
00:06:21,150 --> 00:06:21,920
&nbsp;

84
00:06:21,930 --> 00:06:28,800
そして、通常は、あなたが作業している集計関数の種類に応じて、数値列でのみ機能します。

85
00:06:28,800 --> 00:06:34,140
&nbsp;

86
00:06:34,140 --> 00:06:39,060
あなたは、練習やカプセルプロジェクトを見ながら、グループの練習をもっとたくさんするでしょう。

87
00:06:39,060 --> 00:06:39,720
大丈夫。

88
00:06:39,720 --> 00:06:45,450
みんなありがとう、私は次の講演でお会いしましょう

89
00:06:45,960 --> 00:06:46,480
&nbsp;

90
00:06:46,620 --> 00:06:48,480
&nbsp;
