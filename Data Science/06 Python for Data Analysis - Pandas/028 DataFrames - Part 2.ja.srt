1
00:00:05,430 --> 00:00:06,300
みなさん、こんにちは。

2
00:00:06,300 --> 00:00:09,050
データフレームの第2回講義へようこそ。

3
00:00:09,090 --> 00:00:14,310
前回は、基本データフレームを作成し、そのデータフレームから情報を取得する方法について説明しました。

4
00:00:14,790 --> 00:00:19,760
ここで、条件付き選択とデータフレームのマルチインデックス部分を見てみましょう。

5
00:00:20,430 --> 00:00:23,120
木星ノートブックにジャンプして始めましょう。

6
00:00:23,520 --> 00:00:23,970
大丈夫。

7
00:00:23,970 --> 00:00:25,940
ここでは、木星ノートブックに戻ります。

8
00:00:25,950 --> 00:00:28,460
前回と同じデータフレームを使用しています。

9
00:00:28,470 --> 00:00:35,600
Shurmur私たちは、数字のS＆PのピンPDインポートランドを言う必要があったし、101に座席を設定し、データフレームがレンタルされ、5が来ると言う。

10
00:00:35,600 --> 00:00:38,280
&nbsp;

11
00:00:38,460 --> 00:00:41,270
そしてここに私たちのデータフレームがあります。

12
00:00:42,410 --> 00:00:45,240
さて、条件付き選択について説明しましょう。

13
00:00:45,360 --> 00:00:50,580
&nbsp;

14
00:00:50,690 --> 00:00:57,570
&nbsp;

15
00:00:57,930 --> 00:01:01,070
pantlessの非常に重要な特徴は、ブラケット表記法を使用して条件付き選択を実行する能力であり、これは例えば、データフレームがゼロより大きい場所を尋ねるなど、データフレームに対する比較演算子のPIと非常によく似ています。

16
00:01:01,080 --> 00:01:06,420
私はブール値のバックからデータを取得します。ブール値のデータフレーム値がゼロより大きい場合はtrueを返し、ゼロよりも大きくない場合はfalseを返します。

17
00:01:06,420 --> 00:01:10,620
&nbsp;

18
00:01:10,740 --> 00:01:16,200
これは、このケースでは、フレームの状態をパンしていることを除いて、雇用者全体に適用された同じ条件付き選択と非常に似ています。

19
00:01:16,200 --> 00:01:18,480
&nbsp;

20
00:01:18,480 --> 00:01:27,270
そして、これと同じように、私たちは先に進み、吹き飛ばすと言うとfはDFAがゼロより大きいと言うことができます。

21
00:01:27,960 --> 00:01:29,590
そして、以来、ブーリアと言う。

22
00:01:29,610 --> 00:01:32,470
それをチェックしてください。

23
00:01:32,690 --> 00:01:39,120
&nbsp;

24
00:01:39,120 --> 00:01:48,750
ここでブール値のデータフレームがあり、それを元のデータフレームにブラケット表記で渡すと、結果がtrueだった場所とKnollの場所、またはどこかでfalseになった場所の値が取得されます。

25
00:01:48,750 --> 00:01:49,820
&nbsp;

26
00:01:49,980 --> 00:01:55,200
条件付き選択とデータフレームの併用が可能です。

27
00:01:55,200 --> 00:01:58,830
通常、これを2つのステップに分けることはおそらくないでしょう。

28
00:01:58,890 --> 00:02:00,230
あなたはちょうど言うでしょう。

29
00:02:00,270 --> 00:02:05,760
そして、大括弧でDFのようなものをゼロより大きくすると、この結果が得られます。

30
00:02:06,030 --> 00:02:12,340
データフレームと比較演算子とのこのような操作はそれほど一般的ではありません。

31
00:02:12,370 --> 00:02:17,220
&nbsp;

32
00:02:17,220 --> 00:02:23,700
あなたが行または列の値に渡すデータフレーム全体を渡すのではなく、その行為が何をするかを返すのではなく、サブセットの行または列だけを返すことですあなたの条件が真であるデータフレームの

33
00:02:23,700 --> 00:02:28,970
&nbsp;

34
00:02:28,980 --> 00:02:33,720
さて、元のデータフレームを見ることができなかったという意味の例を示してみましょう。

35
00:02:34,780 --> 00:02:38,830
ここでは、行A-3と列w〜Zがあります。

36
00:02:39,090 --> 00:02:42,900
私が先に進もうとしているのは、指定です。

37
00:02:42,990 --> 00:02:46,580
Wが0より大きい。

38
00:02:46,620 --> 00:02:49,470
そして、シリーズに戻っていることに気付く。

39
00:02:49,470 --> 00:02:54,770
True true false true trueこれは実際のインデックスにリンクされています。

40
00:02:54,780 --> 00:03:01,390
W列を見てみると、これはW列の値に対応し、インデックスCの値は実際にはゼロよりも小さいことがわかります。

41
00:03:01,390 --> 00:03:03,980
&nbsp;

42
00:03:04,110 --> 00:03:06,710
したがって、0より大きい場合はFalseを返します。

43
00:03:06,750 --> 00:03:13,380
私は今列の値に基づいて行をフィルタにする行に対応するブール値のこの一連の値を使用することができます。これは、ブラケット表記を使用してデータフレームに系列を渡すと、DF

44
00:03:13,380 --> 00:03:19,470
&nbsp;

45
00:03:19,470 --> 00:03:26,430
DFWこれが本当である行を返す。私は行abdを取得し、行Cを返さない。なぜなら、ここではfalseだったからだ。

46
00:03:26,720 --> 00:03:32,670
&nbsp;

47
00:03:32,740 --> 00:03:35,340
先に進み、それを実行して、これがどのように見えるかを見てください。

48
00:03:35,340 --> 00:03:36,120
すばらしいです。

49
00:03:36,130 --> 00:03:39,950
そして今、私がシリーズを通過して以来、私はそれらの価値をもはや得られません。

50
00:03:40,050 --> 00:03:44,880
実際に列に基づいて条件を渡しているときに、データフレーム全体でこの種の条件を実行しているときには、これらの値は取得されません。

51
00:03:44,880 --> 00:03:47,470
&nbsp;

52
00:03:47,550 --> 00:03:52,580
あなたはちょうど行が真実であることが起こった得ることを意味するシリーズの値を取得します。

53
00:03:52,650 --> 00:03:57,120
これは、このコースで最も頻繁に使用する条件付き選択の一種です。

54
00:03:58,170 --> 00:04:01,970
このポイントを実際に家に持ち込むためのいくつかの例を紹介しましょう。

55
00:04:01,980 --> 00:04:09,010
たとえば、zが0より小さいデータフレーム内のすべての行を取得したいとします。

56
00:04:09,150 --> 00:04:16,500
だから私はDMFと言う。列Zのfが0より小さい。

57
00:04:16,500 --> 00:04:21,460
Notice列Zで何が起こるべきかを実際に実行する前に、見てみましょう。

58
00:04:21,750 --> 00:04:22,290
それはどこにある。

59
00:04:22,320 --> 00:04:23,150
0より小さい。

60
00:04:23,160 --> 00:04:31,210
まあ、それは行CでZeldaのように列Zだけ起こっていて、次に行Cはcatにあります。

61
00:04:31,260 --> 00:04:33,260
これが返されるべき唯一の行です。

62
00:04:33,270 --> 00:04:35,720
しかし、データ全体をバックから尋ねることを覚えておいてください。

63
00:04:35,850 --> 00:04:40,110
したがって、この行Cを返す必要があります。

64
00:04:40,110 --> 00:04:41,100
そしてそれがあります。

65
00:04:41,340 --> 00:04:42,590
大丈夫です。

66
00:04:42,600 --> 00:04:47,520
今ここで留意すべきことは、あなたがこれらのコマンドを実行しているときに、先に進み、ゼロより大きいR

67
00:04:47,520 --> 00:04:50,190
Wに戻るということです。

68
00:04:50,880 --> 00:04:57,220
これに応答してデータフレームを取得すると、このデータフレームからコマンドを呼び出すことができます。

69
00:04:57,230 --> 00:04:57,880
&nbsp;

70
00:04:58,050 --> 00:05:01,260
次に、これを1ステップまたは2ステップで実行できます。

71
00:05:01,320 --> 00:05:06,370
私は行って結果を言うつもりですDSFはこれと同じですし、結果を見てください。

72
00:05:06,420 --> 00:05:12,910
その行がないデータフレームのこのサブセットであるDMFはそれを参照しています。つまり、Xなどの結果を取得し、ここでXABDとEの4つの値が得られます。その行はチャーリーではないことが分かっている。

73
00:05:13,030 --> 00:05:21,910
&nbsp;

74
00:05:21,910 --> 00:05:25,910
&nbsp;

75
00:05:26,380 --> 00:05:32,200
しかし、実際にはXカラムをつかむなど2つのステップに分けるのではなく、すべてを1ステップで実行できます。

76
00:05:32,200 --> 00:05:33,030
&nbsp;

77
00:05:33,130 --> 00:05:41,230
そして、私が先に進んで、Wの列値がゼロよりも大きくなるデータフレームを返すと言うことを私に教えてください。

78
00:05:41,230 --> 00:05:43,780
&nbsp;

79
00:05:43,780 --> 00:05:45,670
その行を私に返してください。

80
00:05:45,670 --> 00:05:48,050
つまり、すべての行からC行を引いたものです。

81
00:05:48,340 --> 00:05:53,170
これはデータフレームであるため、実際にはXの列を返すなど、その上にブラケット表記などのコマンドを積み重ねることができます。

82
00:05:53,170 --> 00:05:57,530
&nbsp;

83
00:05:57,700 --> 00:06:04,330
そして今、私はここまでの結果と同じ結果を得ましたが、それはすべて一歩で完了しました。これは初めに初心者に脅かされる可能性のあるものです。

84
00:06:04,330 --> 00:06:06,570
&nbsp;

85
00:06:06,670 --> 00:06:09,380
だからここには大量の括弧とたくさんのものがあります。

86
00:06:09,580 --> 00:06:14,620
しかし、基本的には、すべてを複数のステップに分割して、すべてを1つのステップに入れるのではなく、

87
00:06:14,620 --> 00:06:17,480
&nbsp;

88
00:06:17,620 --> 00:06:24,100
同様に、これはデータフレームであるため、コンマXのようなリストを渡すことで複数の列を括弧で括ることができ、ここで結果を得ることができます。

89
00:06:24,100 --> 00:06:29,890
&nbsp;

90
00:06:29,920 --> 00:06:36,100
私たちが取っているステップを示すためにもう一度この行を破ってみましょう。

91
00:06:36,100 --> 00:06:41,090
まず最初に、ブーディアと同じだと言うだろう。

92
00:06:41,680 --> 00:06:48,250
さて、それはbhoolシリーズと言うことになります。それは少し正確です.DFWにいるのはゼロよりも大きいからです。

93
00:06:48,250 --> 00:06:49,140
&nbsp;

94
00:06:49,150 --> 00:06:56,590
だから私がbhoolシリーズと言うと、私はこのブール値のシリーズを取得して、それから私は先に進むつもりですが、その結果がそのブールシリーズのDSFと等しいと言うことです。

95
00:06:56,590 --> 00:07:04,010
&nbsp;

96
00:07:04,510 --> 00:07:06,870
先に進み、結果をチェックしてみましょう。

97
00:07:07,630 --> 00:07:15,690
そしてそれはちょうどそのシリーズが真であったどこにあってもb dとeであり、私の結果があるはずです。

98
00:07:15,820 --> 00:07:18,690
これは、見た行がないデータフレーム全体です。

99
00:07:18,760 --> 00:07:28,200
&nbsp;

100
00:07:28,840 --> 00:07:33,910
&nbsp;

101
00:07:34,360 --> 00:07:43,840
&nbsp;

102
00:07:43,840 --> 00:07:48,760
そして、私は先に進み、その結果を列のリストと呼ぶことができます。そして、なぜカンマXが必要なのか、私たちは実際に別々のものを分離することができます。そのリストを渡してMikeの呼び出し結果を言うと、私たちがここで複数の行のように1行で行ったことと全く同じことができます。

103
00:07:48,910 --> 00:07:53,840
つまり、大量のブラケットやパンダーズのように見えるものにあなたが混乱している場合は、複数のステップに分けることができるかどうかを確認してください。

104
00:07:54,070 --> 00:07:56,110
&nbsp;

105
00:07:56,110 --> 00:08:00,640
コース全体を通してそれがあなたにとって理にかなっているなら、私たちはこのタイプの表記法をやっていきます。

106
00:08:00,910 --> 00:08:02,200
1つのライナーの種類。

107
00:08:02,200 --> 00:08:06,100
&nbsp;

108
00:08:06,100 --> 00:08:11,080
そして、あなたがパンダをますます快適に使うようになるにつれて、これらのライナーを使用する機会がますます増えていきますが、混乱している場合はいつでも自由に複数のステップに分けてください。

109
00:08:11,080 --> 00:08:15,970
複数のステップを実行するという唯一の欠点は、定義した変数でメモリを占有していることです。

110
00:08:16,150 --> 00:08:18,130
&nbsp;

111
00:08:18,220 --> 00:08:23,260
ですから、パンダの方が上手くなるにつれて、これらのコマンドすべての単純な1行の抽象化に移行したいと考えています。

112
00:08:23,260 --> 00:08:24,750
&nbsp;

113
00:08:24,760 --> 00:08:30,370
どうぞ今すぐビデオを一時停止してください

114
00:08:30,370 --> 00:08:36,280
ここでは、複数の行に分かれているのと全く同じことがあります。

115
00:08:36,310 --> 00:08:36,700
大丈夫。

116
00:08:36,700 --> 00:08:38,230
本当に素早く探検しましょう。

117
00:08:38,230 --> 00:08:42,490
2つ以上の条件などの複数の条件を使用する概念。

118
00:08:42,580 --> 00:08:48,940
現在、私たちは、このようなことをすることで、ある条件に基づいてデータフレームのサブセットを返すことに満足しています。

119
00:08:48,940 --> 00:08:50,700
&nbsp;

120
00:08:50,740 --> 00:08:56,320
しかし、wがゼロより大きく、Yが1より大きいなどの複数の条件が必要な場合はどうでしょうか？

121
00:08:56,410 --> 00:08:57,170
&nbsp;

122
00:08:57,520 --> 00:09:06,910
あなたがすることができることは、このようなものを試してみることです。カッコ内は1つの条件で合格し、次に別の条件で言い渡します。

123
00:09:06,970 --> 00:09:10,210
&nbsp;

124
00:09:10,210 --> 00:09:11,740
そして、これはエラーを返すでしょう。

125
00:09:11,970 --> 00:09:17,710
&nbsp;

126
00:09:17,710 --> 00:09:23,410
&nbsp;

127
00:09:23,410 --> 00:09:24,370
そして私はここで何が起こっているのかを説明する目的でこれを行うつもりです。これは初心者がこれをここに置くのがよくある間違いであり、あなたは一連のことがあいまいであると言う間違いがあります。

128
00:09:24,370 --> 00:09:30,520
ここでスクロールすると、一連の真理値があいまいであることがわかります。

129
00:09:30,520 --> 00:09:37,420
&nbsp;

130
00:09:37,750 --> 00:09:43,960
&nbsp;

131
00:09:43,960 --> 00:09:47,680
これは、Pythonの通常の演算子と実際の演算子では、一連のブール値を別の一連のブール値と比較することができず、演算子は一度に1つのブール値しか考慮できないということです。

132
00:09:47,680 --> 00:09:54,790
trueとfalseはFalse Trueを返し、trueはtrueを返します。

133
00:09:55,090 --> 00:10:03,190
つまり、このようなブール値のシリーズ全体を渡すと、演算子は混乱し始めます。

134
00:10:03,190 --> 00:10:04,250
&nbsp;

135
00:10:04,390 --> 00:10:09,880
ブール値のこれらの単一のインスタンスだけを扱うことができます。なぜなら、パンダで作業しているときに、アンパサンドで実際に使用する必要がある複数の条件が必要な場合です。

136
00:10:09,880 --> 00:10:15,230
そして、それはほとんどの標準的なキーボードのためにあなたのキーボードでシフト7になるでしょう。

137
00:10:15,250 --> 00:10:20,360
ここでは、これらの条件を明確に区別するために、これらの条件をカッコで囲んでいることに注目してください。

138
00:10:20,620 --> 00:10:25,660
&nbsp;

139
00:10:25,660 --> 00:10:26,790
そして、私がこれを実行すると、これが真実になる行Eが得られます。

140
00:10:26,920 --> 00:10:31,070
さあ、それを打ち破ろう。

141
00:10:31,510 --> 00:10:32,840
&nbsp;

142
00:10:32,860 --> 00:10:39,430
最後に、複数の条件を使用しようとしているときに、Pythonの標準と演算子を使用することはできません。

143
00:10:39,490 --> 00:10:40,530
&nbsp;

144
00:10:40,960 --> 00:10:47,470
アンパサンドを使用し、複数の条件をかっこで渡し、最後にデータフレームの角括弧内に配置します。

145
00:10:47,470 --> 00:10:49,830
&nbsp;

146
00:10:50,050 --> 00:10:57,130
OR演算を実行したい場合は、これをあなたの右上にあるパイプ演算子で置き換えることができます。

147
00:10:57,180 --> 00:10:57,660
通常、Enterキーのほとんどのキーボードは、その上に移動し、そのバックスラッシュをシフトします。

148
00:10:57,760 --> 00:11:04,110
そして、これはあなたにパイプオペレータを与えるべきであり、それは、あなたが使用しようとした場合、または同じエラーが発生した場合、またはその代わりになるでしょう。

149
00:11:04,240 --> 00:11:09,280
&nbsp;

150
00:11:09,280 --> 00:11:12,160
&nbsp;

151
00:11:12,250 --> 00:11:18,160
だからこそ、それとも、Pythonの普通のやり方で試してみるか、もう一度、私はシリーズの真理値を得るでしょう、あいまいです。

152
00:11:18,160 --> 00:11:18,910
これは、ブール値が1つまたは2つではなく、一連の値を取得するためです。

153
00:11:18,970 --> 00:11:24,380
これの例がもっと必要なら、OKをクリックしてノートを参照することができます。

154
00:11:24,450 --> 00:11:27,840
&nbsp;

155
00:11:27,940 --> 00:11:33,220
&nbsp;

156
00:11:33,220 --> 00:11:41,650
&nbsp;

157
00:11:41,650 --> 00:11:47,140
しかし基本的に、複数の条件がカッコ内の各条件に合格するようにしたい場合は、アンパサンドまたはパイプ演算子を使用して終了するか、今すぐ進んでギアをシフトしてインデックスについて話をしてください。インデックスをリセットするか、別のものに設定しています。

158
00:11:47,170 --> 00:11:48,140
私の前のデータフレームを見てみましょう。

159
00:11:48,160 --> 00:11:50,770
私はここに入って、それらを実行するだけでこれらの細胞をクリアしたいと思います。

160
00:11:50,770 --> 00:11:54,610
私たちのデータフレームを見てみましょう。

161
00:11:54,740 --> 00:11:56,820
&nbsp;

162
00:11:56,860 --> 00:12:03,970
ここでも、インデックスをデフォルトの範囲インデックスに戻すために、列をwからZまでローズしています。これは、範囲インデックスまたは1行2列からn行までです。

163
00:12:03,970 --> 00:12:09,070
&nbsp;

164
00:12:09,210 --> 00:12:16,780
メソッドのアンダースコアのアンダースコアを呼び出すと、実際にそのメソッドを実行している括弧を閉じることができます。

165
00:12:16,870 --> 00:12:18,380
&nbsp;

166
00:12:18,900 --> 00:12:26,950
そしてその通知を呼び出すと、インデックスに列がリセットされ、実際のインデックスが数値になります。

167
00:12:27,010 --> 00:12:28,690
インデックスをリセットする方法です

168
00:12:28,690 --> 00:12:32,320
ここで注目すべきことは、操作のデータを他の多くの手のようにすることです。

169
00:12:32,710 --> 00:12:37,530
これは、その場で発生するように指定しない限り、発生しません。

170
00:12:37,570 --> 00:12:42,010
だから、もし私がTに電話したら。 F. 私はまだあなたが実際に起こっていることが本当に同じであることを確認し、リセットのアンダースコアを渡すことを望むなら、ラベルの元のインデックスを持っています。

171
00:12:42,010 --> 00:12:47,860
&nbsp;

172
00:12:47,860 --> 00:12:54,480
今のところ私たちは先を進め、それをしません。

173
00:12:54,520 --> 00:12:56,640
そうすれば、私たちは元のデータフレームを保持します。

174
00:12:56,650 --> 00:12:59,620
インデックスを数値にリセットしたい場合は、これをもう一度クリアしてください。

175
00:12:59,650 --> 00:13:06,680
あなたはそのReesaインデックスを使うことができ、古いインデックスはデータフレームの列になります。

176
00:13:06,790 --> 00:13:12,080
OK。

177
00:13:12,630 --> 00:13:13,140
&nbsp;

178
00:13:13,300 --> 00:13:19,060
インデックスを設定するなどの新しいインデックスの例をもう一度表示してみましょう。これを行うために、New i n dという新しいインデックスを作成します。

179
00:13:19,150 --> 00:13:25,500
ここでちょっと説明してみましょう。

180
00:13:27,250 --> 00:13:32,910
これは状態の略語の束になるだろう、そして、私はこの文字列に分割して言うつもりです。

181
00:13:33,040 --> 00:13:37,580
文字列を分割すると、空白スペースを分割するための一般的な方法と言えるはずです。

182
00:13:38,020 --> 00:13:44,050
しかしこれは、すべてのカンマを入力するのではなく、リストを作成する素早い方法です。

183
00:13:44,230 --> 00:13:48,960
だから私は先に進んで、本当に新しいものに等しいリストを設定したい。

184
00:13:49,240 --> 00:13:54,850
だから私はここで私の新しいインデックス値を持っていると私は何をするつもりは、私のデータフレーム内の列としてこれを置くことです。

185
00:13:54,850 --> 00:14:02,350
だから私は先に進んで、DFAの状態が新しいものと等しいと言うでしょう。

186
00:14:03,160 --> 00:14:09,520
彼らはマッチを言いますのでここに5つの項目があります。

187
00:14:09,640 --> 00:14:12,610
ここではフレームの状態で0から4に一致します。

188
00:14:12,700 --> 00:14:16,030
だから私が私のデータフレームをチェックするなら、私はこの新しい列を州カリフォルニアNYと呼んでいます。

189
00:14:16,060 --> 00:14:24,070
ここでは、リセットアンダースコアインデックスメソッドを実行しているインデックスをリセットする方法を知っています。

190
00:14:24,100 --> 00:14:29,000
&nbsp;

191
00:14:29,170 --> 00:14:34,150
しかし、データフレームに列にインデックスを追加したい場合は、インデックスをリセットする代わりにインデックスを設定するといいでしょう。

192
00:14:34,150 --> 00:14:37,950
&nbsp;

193
00:14:38,110 --> 00:14:46,120
たとえば、DFドットのアンダースコアを設定して、新しいインデックスにするカラム名を渡して、ここで述べるようにして、シフトすると状態カラムがインデックスになります。

194
00:14:46,120 --> 00:14:54,100
索引のこの情報を保持しないと、古い索引を上書きしても、この情報を実際には新しい列として保持することはできません。

195
00:14:54,100 --> 00:15:00,320
&nbsp;

196
00:15:00,370 --> 00:15:03,630
あなたはその新しい列を持つことができますリセットインデックスとは異なります。

197
00:15:03,760 --> 00:15:07,810
つまり、インデックスとリセットインデックスを設定します。

198
00:15:07,810 --> 00:15:11,280
ここでもデータフレームをチェックアウトすると、これは適切ではありませんでした。

199
00:15:11,340 --> 00:15:14,750
私は引数を追加する必要があります。

200
00:15:14,830 --> 00:15:16,190
私がシフトすれば、ここに入る。

201
00:15:16,210 --> 00:15:18,650
真と等しい。

202
00:15:18,680 --> 00:15:20,140
私が先に進んで、パート3に向かう前に私がちょうどカバーしたものの簡単なレビューをしましょう。

203
00:15:20,810 --> 00:15:28,820
さて、私たちは、PI操作と非常によく似た条件付き選択について学びました。

204
00:15:28,820 --> 00:15:34,180
&nbsp;

205
00:15:34,180 --> 00:15:39,550
あなたは基本的にブール値のデータフレームを取得し、ブール値のデータフレーム全体を渡すと、真である値を取得し、falseの場合はnまたはnoの値を取得します。

206
00:15:39,880 --> 00:15:44,830
&nbsp;

207
00:15:44,830 --> 00:15:52,090
&nbsp;

208
00:15:52,090 --> 00:15:57,850
比較演算子を含む列などの一連のブール値を渡すと、重大な事態が発生したデータフレームの行だけが取得され、必要に応じて複数のステップに分割することができます。

209
00:15:57,910 --> 00:16:00,350
これらの2つのセルはおそらく理解するのが最も重要です。

210
00:16:00,360 --> 00:16:03,160
&nbsp;

211
00:16:03,160 --> 00:16:07,810
この講義の中で、これを理解すれば、無人で条件付き選択を行う方法を理解することができます。

212
00:16:07,810 --> 00:16:08,970
&nbsp;

213
00:16:09,190 --> 00:16:15,490
次にアンダースコアやパイプ演算子を使うことができる複数の条件付き選択をしたい場合は、スクロールダウンしてPythonの組み込み演算子やor演算子を使用することはできません。

214
00:16:15,490 --> 00:16:19,990
&nbsp;

215
00:16:20,170 --> 00:16:27,460
真理値系列ではあいまいな値があるため、括弧を使用して各条件付き選択ステートメントを区切ってください。

216
00:16:27,460 --> 00:16:30,040
そして最後にリセットしました。

217
00:16:30,040 --> 00:16:31,300
&nbsp;

218
00:16:31,330 --> 00:16:38,650
&nbsp;

219
00:16:38,650 --> 00:16:45,670
インデックスのリセットインデックスは、インデックスを数値インデックスにリセットし、古いインデックスを取得してindexという新しい列として設定し、Setを指定するだけで現在の列に基づいてインデックスをリセットするのではなく、新しいインデックスを設定できますアンダースコアインデックス。

220
00:16:45,970 --> 00:16:49,910
これらの方法はどちらもデフォルトでは機能しません。

221
00:16:50,170 --> 00:16:53,090
だから、ECOが正しいかどうかを明記してください。

222
00:16:53,140 --> 00:16:55,560
変更を永続的にしたい場合。

223
00:16:55,690 --> 00:16:57,970
この講義ではそれだけです。

224
00:16:58,030 --> 00:17:00,550
みんな、ありがとう。

225
00:17:00,550 --> 00:17:01,350
私は次の講演で見るか、より高い指数について議論します。

226
00:17:01,390 --> 00:17:04,800
これらのノートはすべて、データフレームと呼ばれるノートブック内にあります。

227
00:17:04,960 --> 00:17:08,630
ありがとう、私は次の講演があるかどうか見てみましょう

228
00:17:08,650 --> 00:17:10,210
&nbsp;
