1
00:00:05,850 --> 00:00:06,770
みなさん、こんにちは。

2
00:00:06,770 --> 00:00:12,180
ようこそ、深刻な講義シリーズは、パンダで作業する最初の主要なデータ型になるだろうし、それは次の講義でデータフレームを扱うCeresから構築されます。

3
00:00:12,180 --> 00:00:17,340
&nbsp;

4
00:00:17,340 --> 00:00:20,610
木星ノートにジャンプして始めましょう。

5
00:00:20,670 --> 00:00:21,150
大丈夫。

6
00:00:21,150 --> 00:00:23,720
ここで私は木星ノートブックにいます。

7
00:00:23,750 --> 00:00:26,430
シリーズはパイ配列に非常に似ています。

8
00:00:26,430 --> 00:00:29,390
実際には実際には海賊のオブジェクトの上に構築されています。

9
00:00:29,430 --> 00:00:35,340
しかし、パンダシリーズとアンパイアアレイを区別することは、一連の軸ラベルがラベルによってインデックス付けできることを意味します。

10
00:00:35,340 --> 00:00:37,410
&nbsp;

11
00:00:37,410 --> 00:00:44,260
重要な審判とPをして、PandursをPeetieとしてインポートしましょう。

12
00:00:44,910 --> 00:00:49,850
そして、まず、さまざまなオブジェクトタイプからさまざまなシリーズを作成することから始めます。

13
00:00:49,920 --> 00:00:56,880
私はPythonオブジェクトを作成するか、labelsというリストを作成します。これはリストAとBの3文字または3文字列になります。

14
00:00:56,880 --> 00:01:00,550
&nbsp;

15
00:01:01,140 --> 00:01:10,290
それから、私は下線データと呼ばれるリストを作成し、それを10 20 30と言うでしょう。

16
00:01:11,190 --> 00:01:16,710
それから私はr rと呼ばれるオブジェクトを作成し、これはニューハンプシャーレイになり、データを渡します。

17
00:01:16,740 --> 00:01:17,940
&nbsp;

18
00:01:18,030 --> 00:01:25,290
&nbsp;

19
00:01:25,290 --> 00:01:38,160
&nbsp;

20
00:01:38,160 --> 00:01:46,220
したがって、1つはPythonリストであり、もう1つは名前PI配列であり、最後に辞書として私はキー10として値として渡されます。Bは値としてキー20であり、次にCはキーであり、30は値を持ちますそれは私が4つの別個のPythonオブジェクトを持っていることを意味します。私のリストにはラベルがあり、次に私のデータがあります。

21
00:01:47,160 --> 00:01:51,740
私は配列を持っていて、ついに私の辞書を持っています。

22
00:01:52,260 --> 00:01:52,850
OK。

23
00:01:53,070 --> 00:01:56,140
シリーズをどのように作成し、実際にどのように見えるかを見てみましょう。

24
00:01:56,220 --> 00:02:02,370
あなたはそのシリーズのPDと言うことができますし、実際にシリーズを保存しているわけではありません。

25
00:02:02,370 --> 00:02:03,870
&nbsp;

26
00:02:04,020 --> 00:02:08,970
しかし、ここでシフト・タブを実行すると、P-T seriousがさまざまなパラメータを取ることに気付くでしょう。

27
00:02:09,030 --> 00:02:14,130
私たちは今、最も重要なものであるデータとインデックスに焦点を当てるだけです。

28
00:02:14,130 --> 00:02:21,000
まず最初に、データを渡すだけでなく、そのリストに渡す私のアンダースコアデータにも等しくなります。

29
00:02:21,000 --> 00:02:24,650
私はここで知っている私は真剣に戻って、それは審判の権利のように多く見えます。

30
00:02:24,930 --> 00:02:33,200
ここでは、インデックス0 1 2と実際のデータ10

31
00:02:33,210 --> 00:02:40,470
20 30があり、パンダシリーズのキーは、実際にインデックスを作成することができるということです。

32
00:02:40,530 --> 00:02:48,240
例えば、私が入り、PDがシリーズに渡し、データが自分のデータと等しいと言って、そのインデックスがラベルと等しいことを指定します。

33
00:02:48,270 --> 00:02:52,120
&nbsp;

34
00:02:52,330 --> 00:02:54,820
それがbとcであることを思い出してください。

35
00:02:54,870 --> 00:02:58,850
だから私は今これを実行すると、私はラベル付きのインデックスシリーズを持っています。

36
00:02:58,890 --> 00:03:04,780
だから私は、ラベルまたはインデックスとして、そしてそのインデックスの実際のデータポイントとして10を持っています。

37
00:03:04,980 --> 00:03:12,060
&nbsp;

38
00:03:12,390 --> 00:03:19,980
&nbsp;

39
00:03:19,980 --> 00:03:21,510
したがって、Mireiの数とは違って、私は実際にこのラベル付きインデックスを使用してこれらのデータポイントを呼び出すことができるという意味のラベルが付いているインデックスを持っています。

40
00:03:21,600 --> 00:03:23,820
データが等しいか、インデックスが等しいと言う必要はありません。

41
00:03:23,880 --> 00:03:30,390
あなたは私のデータを言うだけで、そのようにラベルをつけることができ、同じ方法でシリーズを出すこともできます。

42
00:03:30,600 --> 00:03:34,950
したがって、正しい順序でそれらを置く限り、equalsまたはindexが等しいことを常に指定する必要はありません。

43
00:03:34,980 --> 00:03:36,250
&nbsp;

44
00:03:36,300 --> 00:03:36,800
大丈夫。

45
00:03:36,930 --> 00:03:38,550
あなたにいくつかの方法を示してみましょう。

46
00:03:38,550 --> 00:03:42,660
一連のデータを処理する前にシリーズを作成します。

47
00:03:42,660 --> 00:03:48,910
シリーズを作成するもう一つの素早い方法は、そのシリーズをPと言い、あなたはどんな数をも上げることができるということです。

48
00:03:48,930 --> 00:03:52,340
そして、これはPIの致命的な人物とまったく同じように動作します。

49
00:03:52,380 --> 00:03:54,200
だからここに名前のパス。

50
00:03:54,240 --> 00:03:55,550
そしてそれは同じように働いた。

51
00:03:55,710 --> 00:04:00,790
リストのように、私はこのAmpyraと一緒にラベルを渡すこともできました。

52
00:04:00,900 --> 00:04:03,090
したがって、本質的に審判官の審判が機能します。

53
00:04:03,120 --> 00:04:09,000
シリーズに渡すまではPythonのリストと同じですし、ついに本当にクールなのは、あなたがこれらのシリーズを言うことができ、ちょうど辞書を渡すことができるということです。

54
00:04:09,000 --> 00:04:12,350
&nbsp;

55
00:04:12,480 --> 00:04:17,250
そしてPallaがやることは、表示する辞書のキーを自動的に取得することです。

56
00:04:17,250 --> 00:04:17,800
&nbsp;

57
00:04:17,800 --> 00:04:24,690
ここでもまた、辞書が指摘したキーを取得し、そのキーの値を対応するデータポイントに設定します。

58
00:04:24,840 --> 00:04:26,370
&nbsp;

59
00:04:26,370 --> 00:04:29,460
シリーズをすばやく作成できる素早い方法です。

60
00:04:29,460 --> 00:04:31,610
ここで注意しておいてください。

61
00:04:31,710 --> 00:04:36,630
海賊とパンダシリーズを区別するもう一つのことは、パンダシリーズは実際に様々なオブジェクトタイプを保持できるということです。

62
00:04:36,630 --> 00:04:39,210
&nbsp;

63
00:04:39,210 --> 00:04:46,920
&nbsp;

64
00:04:46,920 --> 00:04:55,660
今はパンダシリーズのPDを示しています。シリーズには数字だけが入っていますので、数字の配列だけを示していますが、ラベルであることを覚えているデータラベル自体を保持することもできます。

65
00:04:55,660 --> 00:04:56,630
&nbsp;

66
00:04:56,640 --> 00:05:01,270
もし私が先に進んで今年走れば、ただのストリングだけです。

67
00:05:01,400 --> 00:05:08,800
&nbsp;

68
00:05:08,810 --> 00:05:14,240
&nbsp;

69
00:05:14,240 --> 00:05:22,670
&nbsp;

70
00:05:22,670 --> 00:05:28,200
だから、シリーズは実際には、データポイントとしてPythonを使ってほとんどあらゆるタイプのデータオブジェクトを保持することができるので、文字列でも、データが等しいと言うよりも面白いかもしれません。何人かのエイリアン王子のように、実際にこのパンダシリーズのデータ​​ポイントとしてこれらの組み込み関数への参照を保持しています。

71
00:05:28,230 --> 00:05:31,840
今は新しいハンプシャーさんなら、それはあなたができることではありません。

72
00:05:32,000 --> 00:05:36,950
おそらくこれを実際に使用することは決してありません。これは、ホスティング関数やリファレンスがAppinシリーズの関数だが、これはAppinシリーズの柔軟性をさまざまなオブジェクトタイプまで保持することを証明するためだけである。

73
00:05:36,950 --> 00:05:42,110
&nbsp;

74
00:05:42,110 --> 00:05:45,020
&nbsp;

75
00:05:45,020 --> 00:05:48,590
さあ、実際にインデックスを使用してみましょう。

76
00:05:48,710 --> 00:05:54,740
シリーズを使用するための鍵は、Pandasのインデックスを理解することです。これらのインデックス名や数字は、非常に高速な情報検索を可能にするため、ハッシュテーブルや辞書のように機能します。

77
00:05:55,010 --> 00:06:00,020
&nbsp;

78
00:06:00,500 --> 00:06:05,100
私たちがこれを行うためにシリーズから情報を得る方法の例を見てみましょう。

79
00:06:05,120 --> 00:06:07,250
私は2つのシリーズを作ります。

80
00:06:07,250 --> 00:06:15,500
私はSVRを1つ作成し、PDシリーズはいくつかのデータを出す予定だと言って、1つ2つ3つ4つと言うので、私のデータのためのリストだけ、次にインデックスのために私は先に進んでドイツに置かれるアメリカのようないくつかの国名は、ソ連とその後に置かれます。

81
00:06:15,560 --> 00:06:20,480
&nbsp;

82
00:06:20,480 --> 00:06:31,280
&nbsp;

83
00:06:31,280 --> 00:06:35,850
だから、これらはいくつかの価値を持つ第二次世界大戦の国名のようなものです。

84
00:06:35,870 --> 00:06:38,760
だからシリーズ1のACR 1をチェックしてみてください。

85
00:06:39,440 --> 00:06:41,760
そしてここに私は真剣に気づく。

86
00:06:41,780 --> 00:06:45,700
今ではインデックスラベルがあり、1つ2つの3つの4つが私のデータポイントです。

87
00:06:45,800 --> 00:06:48,670
そして病気はD型整数64と言う。

88
00:06:48,690 --> 00:06:49,790
これは実際のデータポイントです。

89
00:06:49,790 --> 00:06:51,680
すべての整数です。

90
00:06:51,680 --> 00:06:54,550
それから私は非常に似たような方法でシリーズ2を作るつもりです。

91
00:06:54,560 --> 00:06:58,220
私はPDもシリーズ1と言います。

92
00:06:58,400 --> 00:07:01,200
5：4としましょう。

93
00:07:02,570 --> 00:07:10,850
&nbsp;

94
00:07:10,850 --> 00:07:18,110
&nbsp;

95
00:07:18,110 --> 00:07:21,140
そして、インデックスについては、私は先に進んでアメリカのドイツと言うつもりです。私はこれらのうちの1つを意図的に変えようとします。私たちはイタリアを別の1つか2つの国と言うでしょう。シリーズ2私は1〜5を得る4。

96
00:07:21,150 --> 00:07:24,360
だからイタリアはここで違っていて、別のデータポイントを持っています。

97
00:07:24,380 --> 00:07:29,720
&nbsp;

98
00:07:29,720 --> 00:07:35,420
&nbsp;

99
00:07:35,420 --> 00:07:39,950
今、私が実際にシリーズから情報を取得したいのであれば、シリーズの中のPython辞書タイプの情報を取得し、文字列として実際のインデックスラベルUSAを入力することができます。

100
00:07:39,950 --> 00:07:44,980
今私はインデックスが文字列であることを知っているので、これを文字列としてタイプしています。

101
00:07:45,020 --> 00:07:51,230
私がここで0,1,2のようなシリーズのために働いているなら、整数を渡すだけでした。

102
00:07:51,230 --> 00:07:54,990
実際のインデックスのデータタイプによって異なります。

103
00:07:55,010 --> 00:07:55,950
大丈夫。

104
00:07:56,360 --> 00:07:59,710
通常、あなたのインデックスはうまくいけば番号か文字列のどちらかになります。

105
00:07:59,810 --> 00:08:07,480
seやone、そして文字列やACRのいずれも整数インデックスではありません。

106
00:08:07,490 --> 00:08:12,480
たとえば、SCや3などの別のシリーズをすぐに作成するとします。

107
00:08:12,560 --> 00:08:20,210
さて、PDとそのシリーズを言うと、そのデータをラベルとして渡すだけです。

108
00:08:20,570 --> 00:08:22,800
私はCか3をチェックする。

109
00:08:23,000 --> 00:08:24,980
今私はデータポイントとしてABCを持っています。

110
00:08:24,980 --> 00:08:28,670
型は、それが文字列であるという事実を指すオブジェクトです。

111
00:08:28,880 --> 00:08:34,310
そして、整数インデックスを使ってこれを取り除くことができます。整数インデックスは、通常、これをより高い数値に対してどのように行うかのようなものです。

112
00:08:34,310 --> 00:08:35,510
&nbsp;

113
00:08:35,840 --> 00:08:36,800
そして文字列があります。

114
00:08:36,860 --> 00:08:38,370
私に戻る

115
00:08:38,420 --> 00:08:43,610
したがって、実際のインデックスラベルを渡すだけで、インデックスラベルに対応するデータが返されます。

116
00:08:44,180 --> 00:08:49,750
限り、シリーズを行うための非常に基本的な操作は、通常、インデックスに基づいて行われます。

117
00:08:49,760 --> 00:08:56,960
意味することは、私が1のような何かを言うならば、私たちはCまたは2つを持っていると私はSE1とS -

118
00:08:56,960 --> 00:09:00,080
Eは2つだと言うので、これらを追加しようとしてみましょう。

119
00:09:00,320 --> 00:09:04,970
何が起こるのかは、米国がここに、米国がここにいると言うだろう指数に基づいた操作を合わせようとすることです。

120
00:09:04,970 --> 00:09:08,620
&nbsp;

121
00:09:08,630 --> 00:09:14,480
だから、彼らはそれらを追加して、結果としてアメリカは一致を見つけることができない場所に等しいと言うでしょう。

122
00:09:14,510 --> 00:09:16,060
イタリアなど。

123
00:09:16,070 --> 00:09:19,690
それはNULLを入れて、それからソ連も彼らのためではありません。

124
00:09:19,730 --> 00:09:23,980
それで、そこにネオンオブジェクトを置いて、これを実行するときに何が起こるかを見てみましょう。

125
00:09:24,530 --> 00:09:30,920
そして、我々は結果を見て、アメリカは2だった。 0日本は8歳だった。 00ドイツは4歳だった。 0とし、仕事は一致を見つけませんでした。

126
00:09:30,920 --> 00:09:31,380
&nbsp;

127
00:09:31,400 --> 00:09:33,370
それは先に進み、それをヌル値に入れました。

128
00:09:33,650 --> 00:09:38,870
Pandaの基底オブジェクトが浮動小数点数に変換されるということです。

129
00:09:38,870 --> 00:09:44,730
ここで注意しなければならないのは、あなたがPandursシリーズで操作を実行しているときに、あなたが整数である本当にほとんどすべての名前pyre

130
00:09:45,050 --> 00:09:50,480
そしてそれはあなたが間違いなく奇妙な部門に基づいて情報を失うことはなく、それはPythonの多くをやらなければなりません。

131
00:09:50,480 --> 00:09:51,870
&nbsp;

132
00:09:52,040 --> 00:09:57,680
真のビジョンとクラス分けは、実際には旧バージョンでは区別されています。

133
00:09:58,100 --> 00:10:02,630
基本的にPython

134
00:10:02,630 --> 00:10:09,290
3を使用しているのであれば、これについて心配する必要はありませんが、パンダラーとMPIは常にすべての情報を保持するためにフローを変換することに注意してください。

135
00:10:09,720 --> 00:10:15,380
ここではここで中断して、データフレームを完全に理解するために、シリーズの概念をもっと大きく拡張できるデータフレームに移ります。

136
00:10:15,380 --> 00:10:19,410
&nbsp;

137
00:10:19,460 --> 00:10:23,870
あなたは単にインデックスのラベルを付けたシリーズの基本を知る必要がありますし、このコース全体を通してデータポイントが本当にシリーズではあまり働かないことになります。

138
00:10:23,870 --> 00:10:27,770
&nbsp;

139
00:10:27,770 --> 00:10:32,190
私たちは、パンダの真の働き者であるデータフレームを使ってもっと多くのことを行うつもりです。

140
00:10:32,210 --> 00:10:33,980
先に進んで次の講義に飛びます。

141
00:10:33,990 --> 00:10:37,400
私たちは、これらのデータフレームをpandについてさらに詳しく説明します。

142
00:10:37,400 --> 00:10:39,510
みなさん、ありがとうございます。次の講演でお会いしましょう。
