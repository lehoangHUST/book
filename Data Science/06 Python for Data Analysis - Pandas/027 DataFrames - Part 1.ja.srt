1
00:00:05,850 --> 00:00:10,470
&nbsp;

2
00:00:10,470 --> 00:00:15,170
こんにちは皆さん、データフレームの講義を歓迎します。この講義では、重大なオブジェクトデータフレームを構築するデータフレームについて最終的に学びます。

3
00:00:15,180 --> 00:00:17,800
それはパンダを使って作業するときの主なツールになるでしょう。

4
00:00:17,970 --> 00:00:21,680
木星ノートブックにジャンプして、それがどのように機能するか見てみましょう。

5
00:00:21,690 --> 00:00:22,020
大丈夫。

6
00:00:22,020 --> 00:00:24,410
ここで私は木星ノートにいます。

7
00:00:24,450 --> 00:00:29,940
私たちは先に進み、いくつかのパイとPとimport

8
00:00:29,940 --> 00:00:35,880
pandas PDを重要と言っていきます。そしてPied-Botの無作為輸入Randとから彼らを救うために最後のことをここでやろうと思います。

9
00:00:36,350 --> 00:00:38,370
そして、私は外に出て種をつけるつもりです。

10
00:00:38,370 --> 00:00:42,660
シードとは、同じ乱数を得ることだけです。

11
00:00:42,660 --> 00:00:45,510
そうすれば、あなたが私に従っているなら、あなたは同じ乱数を見るでしょう。

12
00:00:45,540 --> 00:00:49,260
私は彼女が行くことができ、そのランダムな種を言うことができます。

13
00:00:49,290 --> 00:00:49,550
大丈夫。

14
00:00:49,590 --> 00:00:57,840
ADFはPDのデータフレームと同じで、実際にはJupiterのタブを使ってこれを自動完成させることができます。

15
00:00:57,840 --> 00:01:01,460
&nbsp;

16
00:01:01,770 --> 00:01:05,200
そして、EFISがWinduシフトタブを利用することに気付く。

17
00:01:05,200 --> 00:01:10,770
このPDデータフレームのdocstringと最初の署名をチェックしてください。

18
00:01:10,770 --> 00:01:16,830
我々は一連のデータと同じようにデータ引数とインデックス引数を持っていますが、この追加の列引数があります。

19
00:01:16,830 --> 00:01:18,210
&nbsp;

20
00:01:18,450 --> 00:01:23,130
何らかのランダムなデータでこれを構築し、データフレームが実際にどのように見えるかを見ていきましょう。

21
00:01:23,130 --> 00:01:24,000
&nbsp;

22
00:01:24,000 --> 00:01:31,090
私がやろうとしているのは、そのデータ引数を渡すことです。実際にRanzと5カンマ4を呼び出し、次に渡すべきものはインデックスのインデックスです。

23
00:01:31,110 --> 00:01:37,620
&nbsp;

24
00:01:37,620 --> 00:01:42,650
ここに文字のリストを作ることができます。

25
00:01:42,660 --> 00:01:48,850
私は入ってA B C D E.と言うつもりです。

26
00:01:49,320 --> 00:01:53,950
そして最後に列のために私は先に進んでxy zを言うつもりです。

27
00:01:54,120 --> 00:02:05,810
ですから、私はw x y zが先に進んでこれを実行して、ちょうど表示されたデータを渡してからうまく表示すると言うでしょう。

28
00:02:05,820 --> 00:02:07,020
&nbsp;

29
00:02:07,050 --> 00:02:12,370
そして、これはおそらく、Excelのエントリと深いノートブックのように見えて、よく感じています。

30
00:02:12,540 --> 00:02:18,060
あなたが別のIDエディタを使用している場合、あなたはこのような素晴らしい表示を得ることはできませんが、これに似た印刷出力を得るべきです。

31
00:02:18,060 --> 00:02:21,560
&nbsp;

32
00:02:21,630 --> 00:02:22,060
大丈夫。

33
00:02:22,110 --> 00:02:31,130
ですから、基本的にここでは列w x y zと対応する行A B C D Eのリストがあります。

34
00:02:31,170 --> 00:02:35,240
現在、これらの列はそれぞれ実際にはパンダのシリーズです。

35
00:02:35,250 --> 00:02:42,060
だから、Wはパンダシリーズだけでなく、X

36
00:02:42,060 --> 00:02:46,350
YとZであり、それらはすべて共通のインデックスを共有しています。基本的にすべてのデータフレームは、インデックスを共有する一連のシリーズです。

37
00:02:46,350 --> 00:02:51,830
&nbsp;

38
00:02:52,080 --> 00:02:59,280
&nbsp;

39
00:02:59,340 --> 00:03:02,920
ここでは、インデックス作成と選択を使用して実際にこれらの重大なオブジェクトの1つまたはこれらの列のいくつかを一方向に取り出す方法を示します。これを行う主な方法は、DMFと次にRackett表記を使用して列名。

40
00:03:02,940 --> 00:03:05,590
この場合、W列をつかみましょう。

41
00:03:05,610 --> 00:03:12,180
したがって、パスwの文字列として、これはW列を返し、出力を見ます。

42
00:03:12,180 --> 00:03:14,590
これは実際にはシリーズのように見えます。

43
00:03:14,590 --> 00:03:16,950
そして、それはまさにW列のものなのですから。

44
00:03:16,950 --> 00:03:20,160
それはちょうどシリーズであり、あなたは実際に言ってこれを確認することができます。

45
00:03:20,160 --> 00:03:27,870
Wのd fのタイプで、そのシリーズの中核をなすPanasだということを示しています。

46
00:03:27,870 --> 00:03:33,940
DFAオブジェクト自体に型を指定すると、データフレームが取り出されます。

47
00:03:34,260 --> 00:03:39,420
つまり、データフレームは同じインデックスを共有する一連のシリーズに過ぎないという事実を繰り返し述べてください。

48
00:03:39,450 --> 00:03:40,600
&nbsp;

49
00:03:40,590 --> 00:03:45,270
データフレームから列を取得する方法は2通りあります。

50
00:03:45,300 --> 00:03:49,780
主な方法と方法は、常にこのような大括弧表記を使用し、列名を渡すことです。

51
00:03:49,800 --> 00:03:51,090
&nbsp;

52
00:03:51,090 --> 00:03:56,640
しかし、あなたが本当に続編をよく知っている場合は、テーブルに渡した列を選択してから列名を選択します。

53
00:03:57,090 --> 00:03:58,470
&nbsp;

54
00:03:58,530 --> 00:04:04,280
これは実際には、あなたはドットと列の名前を言うことができますpantlessのために動作します。

55
00:04:04,440 --> 00:04:10,020
しかし、データフレームから利用できるさまざまな方法と混同される可能性があるため、これを使用しないことをお勧めします。

56
00:04:10,020 --> 00:04:11,870
&nbsp;

57
00:04:11,940 --> 00:04:18,160
例えば、DFAの点を言ってからタブをクリックすると、私のために利用できるメソッドがたくさんあります。

58
00:04:18,480 --> 00:04:22,980
&nbsp;

59
00:04:22,980 --> 00:04:28,050
&nbsp;

60
00:04:28,050 --> 00:04:32,420
これらは、パンダについてもっと学ぶときに学ぶべき方法の集まりですが、これらのメソッドの1つが列名で上書きされ、次にPantherがあなたに質問しているかどうかを混乱させるでしょうメソッドまたは実際の列名の場合

61
00:04:32,430 --> 00:04:38,410
ですから、列を要求する際には、いつものように大括弧の表記法を使用しないようにする必要があります。

62
00:04:38,970 --> 00:04:39,500
OK。

63
00:04:39,510 --> 00:04:44,590
複数の列を元に戻したい場合は、列のリストを先に進めることができます。

64
00:04:44,820 --> 00:04:49,800
だから、私が括弧で囲まれていることを知ってから、私は渡すつもりで、列名のリストは別の括弧で囲まれます。

65
00:04:49,800 --> 00:04:52,170
&nbsp;

66
00:04:52,200 --> 00:05:02,970
例えばWとZの列にしたい場合は、ここで強調表示されているWNCのリストを渡して、その2つの系列を含むデータフレームを返します。

67
00:05:02,970 --> 00:05:05,520
&nbsp;

68
00:05:05,520 --> 00:05:10,620
つまり、複数の列を尋ねると、実際にはデータフレームが戻ってきて、列を1つだけ求めてシリーズを返すことになります。

69
00:05:10,620 --> 00:05:13,240
&nbsp;

70
00:05:13,380 --> 00:05:17,510
そして、木星のノートブックシステムでは、出力が表示される方法で注目されます。

71
00:05:17,990 --> 00:05:25,540
[OK]をクリックして、新しい列を作成します。Palla'sは、列が既に存在するかのように指定するだけで、新しい列の作成をサポートします。

72
00:05:25,560 --> 00:05:29,390
&nbsp;

73
00:05:29,400 --> 00:05:31,100
たとえば、新しい。

74
00:05:31,140 --> 00:05:34,550
今私がこれを実行するとエラーが発生し、それはキーパーです。

75
00:05:34,570 --> 00:05:37,500
ここまでスクロールするとKear newと言えます。

76
00:05:37,680 --> 00:05:42,560
それは基本的にちょうどそこに新しいことがないということを見つけることができないとあなたに伝えようとしています。

77
00:05:42,570 --> 00:05:50,190
しかし、ハッシュタグを作成しているときは、新しい列を作成するときにこれを戻して入れてください。

78
00:05:50,190 --> 00:05:51,200
&nbsp;

79
00:05:51,210 --> 00:05:56,280
new

80
00:05:56,850 --> 00:06:05,610
columnを言うことができます。 DFWプラスフライ。

81
00:06:05,610 --> 00:06:09,970
あなたはすでにそれがすでに存在するかのように定義することができますし、等号の右辺に算術演算を伴う他の列を使用して、新しい列を引き出すために、すでに存在するかのようにDSF

82
00:06:10,150 --> 00:06:11,710
これはエラーなしで実行されます。

83
00:06:11,910 --> 00:06:18,780
そして、もし私がDFをチェックすると、その新しい列がそこに実際にあり、列を削除するためにDFTと言うことができます。

84
00:06:18,780 --> 00:06:19,890
&nbsp;

85
00:06:19,920 --> 00:06:28,020
ドロップすると、削除したい実際の列名を削除して渡すことができます。

86
00:06:28,020 --> 00:06:31,430
今、あなただけでこれを行うなら、あなたはエラーを起こすでしょう。

87
00:06:31,500 --> 00:06:35,340
そして、そのエラーが何を意味するのかをチェックしてみましょう。

88
00:06:35,390 --> 00:06:36,120
下にスクロールします。

89
00:06:36,120 --> 00:06:40,540
それは、Accessに含まれていない新しいラベルだと言います。

90
00:06:40,620 --> 00:06:47,660
ドロップメソッドのシフトタブをクリックすると、デフォルトでは、ドロップメソッドのゼロアクセスに等しいアクセスがインデックスと同じであることが通知されます。

91
00:06:47,670 --> 00:06:52,390
&nbsp;

92
00:06:52,500 --> 00:07:01,050
実際にアクセスを指定する必要がある列を参照したい場合は、1にしてから新しい列をここにドロップします。

93
00:07:01,680 --> 00:07:04,430
&nbsp;

94
00:07:04,830 --> 00:07:10,260
&nbsp;

95
00:07:10,260 --> 00:07:15,900
&nbsp;

96
00:07:16,070 --> 00:07:18,370
このDFTドロップを使用する際に注意すべき2つのことがあります。最初に知るべきことは、これが現実に起こらないということです。フレームの状態に実際には影響しません。

97
00:07:18,470 --> 00:07:20,450
私はそれが意味するものをあなたに見せたいと思います。

98
00:07:20,610 --> 00:07:28,380
私はこのラインをDフラットドロップと呼んでいます。私がDMFと呼んでいれば、それは1に等しくなります。私はまだその新しいカラムを持っていることがわかります。

99
00:07:28,380 --> 00:07:29,910
&nbsp;

100
00:07:29,910 --> 00:07:36,030
&nbsp;

101
00:07:36,630 --> 00:07:42,840
つまり、実際にシフトするための引数として指定する必要があることは、多くの多くのPandursメソッドでインプレース引数をtrueに設定する必要があります。

102
00:07:42,990 --> 00:07:48,450
そして、放浪者がそれをするのは、あなたが誤って情報を失うことがないように、あなたがデータを調整した場合に、誤って情報を失わないようにするためです。

103
00:07:48,450 --> 00:07:53,820
&nbsp;

104
00:07:53,820 --> 00:07:59,520
だからPandursは、あなたが実際にこれらの変更をたくさん残してその場で起こさせたいと思うなら、インプレースが真であると言うことを要求します。

105
00:07:59,550 --> 00:08:01,260
&nbsp;

106
00:08:01,380 --> 00:08:07,800
&nbsp;

107
00:08:07,800 --> 00:08:15,960
そして今私がDFIを呼び出してセルを実行すると、新しい列が削除されていることに気付くと、ここで注意するべきことは、左のドロップを使用して行をドロップすることができるということです。

108
00:08:15,960 --> 00:08:16,450
&nbsp;

109
00:08:16,470 --> 00:08:19,930
外に出て、これを使って行を落としましょう。

110
00:08:20,130 --> 00:08:28,290
私はDFが落ち込んでEを渡し、軸がゼロに等しいと言うこともできると言うでしょう。

111
00:08:28,290 --> 00:08:30,870
実際には、引数として追加する必要はありません。

112
00:08:30,870 --> 00:08:32,230
これがデフォルトです。

113
00:08:32,820 --> 00:08:40,950
だから行きましょうとドロップEと言うだけで、Accessはゼロに等しいのでeを落とすことができました。

114
00:08:40,950 --> 00:08:41,410
&nbsp;

115
00:08:41,460 --> 00:08:45,260
そして、それはXの続編を0と言うことができるどちらの方法でも動作し、これは再び動作します。

116
00:08:45,660 --> 00:08:48,140
ここでは、私はこれを適切に実行していないことに注意してください。

117
00:08:48,360 --> 00:08:48,880
OK。

118
00:08:49,020 --> 00:08:54,930
時には、混乱のポイントは、なぜ行がゼロであるかということです。なぜなら、アクセスがある限り、なぜ列が参照が実際にπに戻ってくるのかです。

119
00:08:54,960 --> 00:08:58,880
&nbsp;

120
00:08:59,010 --> 00:09:06,850
データフレームは本質的にPI配列の上にある見栄えのよいインデックスマーカーであるため、これを示しています。

121
00:09:07,080 --> 00:09:14,750
私はDFの考え方をパイプ行列のように思っていますが、その形状がここではゼロのインデックスまたは行数で歯の想像線行列のタプルであるとは言えません。

122
00:09:14,800 --> 00:09:19,750
&nbsp;

123
00:09:19,890 --> 00:09:23,020
だから私がここでZFと言うなら、私は五つの行を持っています。

124
00:09:23,070 --> 00:09:29,990
A B CとD E、そしてインデックス1には4つの列w x y zがあります。

125
00:09:30,150 --> 00:09:37,530
これは、行がゼロ軸と呼ばれ、列が1つの軸と呼ばれる理由です。なぜなら、円の配列と同じように、形状から直接取り出されているからです。

126
00:09:37,530 --> 00:09:43,020
&nbsp;

127
00:09:43,020 --> 00:09:43,880
OK。

128
00:09:43,920 --> 00:09:46,260
次に、行の選択について説明します。

129
00:09:46,290 --> 00:09:51,840
ここでは、DMFと言うだけで列を選択する方法について説明しました。括弧内に列名を渡します。

130
00:09:51,840 --> 00:09:53,280
&nbsp;

131
00:09:53,280 --> 00:10:01,350
また、多くの列が必要な場合は、Zや括弧Xなどの列名のリストを作成し、その括弧を閉じます。

132
00:10:01,350 --> 00:10:02,430
&nbsp;

133
00:10:02,430 --> 00:10:07,460
だから私は列名のリストを渡していると私はそれらの列のデータフレームを返します。

134
00:10:07,500 --> 00:10:09,940
行の選択についてお話しましょう。

135
00:10:10,900 --> 00:10:14,650
私のデータフレームをもう一度見たいのですが、私のデータフレームはここにあります。

136
00:10:14,650 --> 00:10:18,400
ABC Eは私のバラですWXYZは列です。

137
00:10:18,400 --> 00:10:25,120
データフレーム内の行を選択するには2通りの方法があり、その方法を呼び出す必要があります。

138
00:10:25,120 --> 00:10:26,900
そして、2つの方法があります。

139
00:10:26,890 --> 00:10:31,040
1つはLoek EHLOは場所を参照してください。

140
00:10:31,690 --> 00:10:38,030
そして、これはラベルを取るので、あなたはここでこのプロパティとここで知ることを見るためにシフトタブを行うこともできます。

141
00:10:38,020 --> 00:10:38,540
&nbsp;

142
00:10:38,560 --> 00:10:43,770
私はちょっと変わった角括弧を使用していますが、それはパンダで動作する方法です。

143
00:10:44,000 --> 00:10:48,920
あなたはLRCを渡して、あなたが望む行を括弧で囲みます。

144
00:10:48,910 --> 00:10:52,030
例えば、私が行を望むならば、私はただpassenします。

145
00:10:52,280 --> 00:10:56,210
そのインデックスのラベルを渡してください。これが返されます。

146
00:10:56,240 --> 00:10:58,150
シリーズはありません。

147
00:10:58,150 --> 00:11:04,310
そして、これは我々の第二の結論になる。列シリーズだけでなく列もシリーズであるだけでなく、彼らがリターンを得る方法である。

148
00:11:04,300 --> 00:11:06,730
&nbsp;

149
00:11:06,880 --> 00:11:09,780
あなたがパンダでそれらを要求するとき。

150
00:11:10,090 --> 00:11:16,140
次に、次の位置に基づいて行を取得する2番目の方法について説明します。

151
00:11:16,510 --> 00:11:17,750
私はDFTを使うことができます。

152
00:11:17,840 --> 00:11:25,180
私の軸が文字列でラベル付けされていても、数値インデックスの位置に実際に笑う。

153
00:11:25,180 --> 00:11:34,310
例えば、私はその行を見たい場合、私はDF

154
00:11:34,380 --> 00:11:42,190
ELOが場所を見て、括弧内にCである行名を渡すか、EHLOがどのインデックスベースの場所であるかを調べ、どのインデックスそれは言う。

155
00:11:42,200 --> 00:11:43,690
&nbsp;

156
00:11:43,690 --> 00:11:45,870
だから0 1 2。

157
00:11:46,100 --> 00:11:51,790
そして、私はAlosi上でこれを追加することを急いでも、その行を返します。

158
00:11:51,790 --> 00:11:57,250
&nbsp;

159
00:11:57,250 --> 00:12:04,220
基本的には、EHLOを使用して行を選択する2つの方法があることを意味します。場所を指定するかラベルベースのインデックスを使用するか、数字ベースのインデックスを使用するかどうかを確認してください。

160
00:12:04,240 --> 00:12:09,640
[OK]をクリックして行と列のサブセットを選択する方法について説明します。

161
00:12:09,640 --> 00:12:12,680
&nbsp;

162
00:12:13,250 --> 00:12:21,530
DFIは、EHLOが、Numと同じように、行と列のサブセットを選択したいかどうかを見ていると考えています。

163
00:12:21,520 --> 00:12:25,400
Piは共通表記を使用します。

164
00:12:25,390 --> 00:12:28,550
私たちが望む行と、次に私たちが望む列。

165
00:12:28,580 --> 00:12:36,520
ですから、私はRowの値をY列にして、そこにただ一つの値を返します。

166
00:12:36,550 --> 00:12:43,220
だから私は再び私のDFAを見て、列yでrรกを見て、私はこの負の0を持っています。 8私はここで同じ結果を得ます。

167
00:12:43,210 --> 00:12:44,610
&nbsp;

168
00:12:44,620 --> 00:12:52,700
ellosがコンマで区切られたリストを参照して、それを無視すると言うことができます。

169
00:12:52,690 --> 00:12:58,950
だからpiと同じように、この行のカンマ列表記を使用することができます。そして、このサブセットが必要な場合は、Dhia

170
00:12:59,000 --> 00:13:07,180
たとえば、私はWの列を持つb行のサブセットを必要としていたとしましょう。

171
00:13:07,540 --> 00:13:13,670
7 0。 9および0である。 6 5であり、ネガは24である。

172
00:13:13,690 --> 00:13:20,650
つまり、私はこの場合aとbである行のリストを渡すことができます。

173
00:13:21,700 --> 00:13:31,490
そして、私はこのケースではwとyシフトを入力したいカラムのリストを渡すことができ、そのデータフレームのサブセットリターンを取得します。

174
00:13:31,490 --> 00:13:34,360
&nbsp;

175
00:13:34,880 --> 00:13:35,540
OK。

176
00:13:35,770 --> 00:13:38,520
私たちはここでここでやめ、議論を続けるつもりです。

177
00:13:38,530 --> 00:13:44,960
データフレームの講義の第2部では、これはすべてノートブックのpanderersフォルダの下にあるデータフレームと呼ばれています。

178
00:13:44,950 --> 00:13:46,700
&nbsp;

179
00:13:46,690 --> 00:13:51,610
私たちがデータフレームを作成するまで学んだ内容を簡単に見直しましょう。

180
00:13:51,620 --> 00:13:58,540
PDデータフレームの乗客データをインデックスに入れ、列名を渡すだけです。

181
00:13:58,930 --> 00:14:03,670
通常、私たちはデータFrayneを手作業で構築しません。この方法は実際にはCSPファイルのようなソースからデータを読み込みますが、後でデータ入力を行う方法を学びます。

182
00:14:03,670 --> 00:14:08,250
&nbsp;

183
00:14:08,250 --> 00:14:14,030
今のところ、主にデータフレームを作成してデータフレームから列を選択できるようにする場合は、DSFと言うことができます。

184
00:14:14,020 --> 00:14:16,100
&nbsp;

185
00:14:16,100 --> 00:14:22,090
そして、大括弧の中にあなたが望む列を渡すか、列のリストを渡します。各列は実際には単なる列であることを覚えておいてください。

186
00:14:22,180 --> 00:14:25,630
&nbsp;

187
00:14:25,880 --> 00:14:31,430
この種の算術演算を使用して、古い列に基づいて新しい列を作成することができます。

188
00:14:31,450 --> 00:14:36,040
次に、ドロップするDFAを使用して列または行を削除できます。

189
00:14:36,040 --> 00:14:38,730
場所の言葉の必要性が真実と同じであることを忘れないでください。

190
00:14:38,870 --> 00:14:44,820
エフェクトを永続させる場合は、列の軸1とし、行の0を指定します。

191
00:14:44,980 --> 00:14:54,460
そして、この形状タプル0インデックスから来たのは、データフレームから行を選択する限り、行1インデックスは列でした。

192
00:14:54,460 --> 00:14:56,350
&nbsp;

193
00:14:56,360 --> 00:14:57,630
ここには2つの方法があります。

194
00:14:57,640 --> 00:15:03,670
Alosiの方法は、ラベルベースのインデックス位置またはドットがあります。

195
00:15:03,720 --> 00:15:08,670
I Alosiは整数ベースのインデックス位置です。

196
00:15:09,430 --> 00:15:15,100
次に、データフレームのサブセットを選択する場合は、ドットLOCを使用して値または完全リストを渡して、データフレームのサブセットを戻すことができます。

197
00:15:15,250 --> 00:15:18,800
&nbsp;

198
00:15:19,330 --> 00:15:22,230
それはデータフレームの非常に基本的なものです。

199
00:15:22,420 --> 00:15:26,810
次に、私たちは、条件付き選択を使用するなど、フレームの状態をAppinで行うことができることについてさらに議論するつもりです。

200
00:15:26,800 --> 00:15:28,880
&nbsp;

201
00:15:28,880 --> 00:15:30,580
皆、おかげです。

202
00:15:30,590 --> 00:15:31,570
私は次の講義でお会いしましょう
