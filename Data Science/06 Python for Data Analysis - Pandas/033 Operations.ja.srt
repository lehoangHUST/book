1
00:00:05,400 --> 00:00:10,170
&nbsp;

2
00:00:10,170 --> 00:00:15,090
&nbsp;

3
00:00:15,090 --> 00:00:15,930
皆さんこんにちは皆さん、そしてこの講演会を歓迎します。この講義では、パンダにとって最も重要な作業のいくつかを見直し、まだ完了していない便利な作業について学びます。

4
00:00:16,290 --> 00:00:19,850
木星ノートブックにジャンプして始めましょう。

5
00:00:19,860 --> 00:00:20,160
大丈夫。

6
00:00:20,160 --> 00:00:22,020
ここで私は木星ノートブックにいます。

7
00:00:22,020 --> 00:00:26,520
私は先に進んで、このデータフレームを作成するためにこの講義に付随する本は、操作の最初のセルをコピーしたものです。

8
00:00:26,850 --> 00:00:28,830
&nbsp;

9
00:00:28,830 --> 00:00:30,060
それはちょうど3つの列があります。

10
00:00:30,060 --> 00:00:37,940
1を呼び出して3にコールし、0 1 2 3という数字のインデックスを持ち、1を呼び出して4桁を持ち、2を呼び出します。

11
00:00:37,940 --> 00:00:38,520
&nbsp;

12
00:00:38,700 --> 00:00:40,550
ここには4つの数字があります。

13
00:00:40,680 --> 00:00:46,460
しかし、4 4 4が繰り返されていることに気付き、次に3を呼び出すと4つの文字列があるだけです。

14
00:00:46,470 --> 00:00:49,780
データフレーム内で一意の値を見つけることについて話しましょう。

15
00:00:49,800 --> 00:00:56,460
データフレームで一意の値を見つけることに関連する3つの主な有用な方法があります。

16
00:00:56,460 --> 00:01:00,570
列2のすべての一意の値を探したかったとします。

17
00:01:00,690 --> 00:01:07,590
そのために使用できるメソッドは一意のメソッドであり、実際には一意の値の配列を必要とするのではなく、列2のすべての一意の値の割合が高くなります。

18
00:01:07,590 --> 00:01:13,110
&nbsp;

19
00:01:13,110 --> 00:01:16,960
実際に値の数自体がほしいと思っているとしましょう。

20
00:01:16,980 --> 00:01:18,600
これには2つの方法があります。

21
00:01:18,630 --> 00:01:24,930
返される配列の長さと、列2の3つまたは3つの一意の値に対する応答の並べ替えをチェックすることができます。

22
00:01:24,930 --> 00:01:26,210
&nbsp;

23
00:01:26,580 --> 00:01:31,740
しかし、Haloは実際にはこれのための方法で構築されており、それはちょうどユニークです。

24
00:01:31,770 --> 00:01:34,670
私がセルを走らせると、私は同じ答えを得ます。

25
00:01:34,740 --> 00:01:35,190
大丈夫。

26
00:01:35,280 --> 00:01:36,600
だから私たちはユニークです。

27
00:01:37,110 --> 00:01:40,750
一意の値の配列と一意の配列を実際に返します。

28
00:01:41,010 --> 00:01:46,890
私がユニークな値の数を望むなら、私があなたに示したいと思う有用性の低い関数は、値の数です。

29
00:01:46,950 --> 00:01:52,470
そして、これは基本的に、ユニークな値の表を表示したい場合、値のアンダースコアをメソッドとして使用することができます。

30
00:01:52,470 --> 00:01:57,300
&nbsp;

31
00:01:57,420 --> 00:02:00,440
これを実行すると、これが返されます。

32
00:02:00,660 --> 00:02:03,980
各列のユニークな値が何回発生したか。

33
00:02:04,010 --> 00:02:09,810
この場合、4 4 4は2回発生し、他の数はそれぞれ1回ずつ発生します。

34
00:02:09,810 --> 00:02:14,490
すべての権利は3つの非常に便利な方法であり、演習でそれらを頻繁に使用していることがわかります。

35
00:02:15,210 --> 00:02:18,390
データの選択について説明しましょう。

36
00:02:18,480 --> 00:02:24,300
私たちはすでに条件付き選択を行ってきましたが、それがどれほど重要であり、ツールとしてどれだけ強力であるかを強調したいと思います。

37
00:02:24,300 --> 00:02:26,420
&nbsp;

38
00:02:26,610 --> 00:02:33,810
私たちはデータフレームDMFを持っており、T.を返すという条件付き選択文を渡すことによって条件付き選択を使用することができます。

39
00:02:33,810 --> 00:02:41,160
F. ここで、列1は2より大きい。

40
00:02:41,250 --> 00:02:46,410
これにより、データフレームのすべての行が返されます。ここで、列1は2より大きい値になります。

41
00:02:46,500 --> 00:02:53,920
このコマンドは、本質的に単なる真偽値の真偽値である真偽値であることを覚えておいてください。

42
00:02:54,000 --> 00:03:00,630
条件を結合する場合は、これらの条件をかっこで囲み、アンパサンドまたはパイプ演算子を使用することができます。

43
00:03:02,070 --> 00:03:05,090
&nbsp;

44
00:03:05,220 --> 00:03:07,140
あなたがしたいならばペニー。

45
00:03:07,410 --> 00:03:15,090
そして、あなたはあなたに送られた場所に文字列があり、4 4

46
00:03:15,090 --> 00:03:21,600
4の品質を持っていて、最後の行3だけ戻っているなど、他の条件で言うことができます。

47
00:03:21,900 --> 00:03:23,000
OK。

48
00:03:23,000 --> 00:03:26,640
したがって、条件付き選択を使用してデータを選択する方法を素早く思い出させるだけです。

49
00:03:26,910 --> 00:03:33,030
次に、適用されたメソッドについて説明しましょう。適用されるメソッドは、パンダラーを使用するときにツールベルトで最も強力なツールの1つになります。

50
00:03:33,120 --> 00:03:35,180
&nbsp;

51
00:03:35,400 --> 00:03:38,080
それで、外出してどのように動作するかを見てみましょう。

52
00:03:38,190 --> 00:03:52,640
Maginには、DPFの2倍の値をとってXを2回返す関数があります。

53
00:03:52,650 --> 00:03:54,920
大丈夫、非常に単純な機能。

54
00:03:55,020 --> 00:04:01,740
これで、すでに列を取得し、その列の合計などの組み込み関数を呼び出すことができます。

55
00:04:01,890 --> 00:04:05,660
&nbsp;

56
00:04:05,700 --> 00:04:10,270
しかし、時間のような独自のカスタム関数をあまりにもうまく適用したい場合はどうでしょうか？

57
00:04:10,320 --> 00:04:11,840
それを行う能力があります。

58
00:04:11,880 --> 00:04:18,300
あなたは単に列の名前を言うことができますし、次に適用すると、我々は先に進んで時間を適用するこのケースを適用する関数を渡すだけで、その関数はその列の各要素にブロードキャストされます2

59
00:04:18,300 --> 00:04:25,830
4 6

60
00:04:25,830 --> 00:04:29,990
8。

61
00:04:30,000 --> 00:04:33,040
長さなどの組み込み関数を適用することもできます。

62
00:04:33,120 --> 00:04:37,820
たとえば、3列目を見てみると、たくさんの文字列がありました。

63
00:04:37,860 --> 00:04:41,370
各列の長さに列が存在したかったとしましょう。

64
00:04:41,370 --> 00:04:47,520
さて、私たちはちょうどElyonを人に当てはめると言うことができ、それはストリームの長さを返します。このストリームの長さは、この場合、すべての文字列に対して適用されます。

65
00:04:47,520 --> 00:04:50,880
&nbsp;

66
00:04:50,880 --> 00:04:54,530
土地表現と組み合わせると特に強力になるでしょう。

67
00:04:54,570 --> 00:04:58,030
そうすれば、関数全体を定義するために全時間を取る必要はありません。

68
00:04:58,050 --> 00:05:02,580
たとえば、それを一度適用する場合は、先に進み、時間外にランプ式を作成してみましょう2。

69
00:05:02,580 --> 00:05:03,700
&nbsp;

70
00:05:03,870 --> 00:05:12,960
私は外に出てラムダXのコロンを言うつもりだし、ちょうどx倍の2私は彼に電話するためにこれを適用するつもりです。

71
00:05:12,990 --> 00:05:13,920
&nbsp;

72
00:05:14,370 --> 00:05:16,160
これがどう動くか見てみましょう。

73
00:05:16,820 --> 00:05:17,600
そしてそこにあなたはそれを持っています。

74
00:05:17,680 --> 00:05:23,050
その列の各値に2を掛けることができ、そのために関数全体を記述することなくこれを実行することができました。

75
00:05:23,040 --> 00:05:25,220
&nbsp;

76
00:05:25,240 --> 00:05:29,340
私たちはちょうどこれを子羊のように表現しました。これはあなたがパンダにますます慣れるにつれ、いつも使っているようなものです。

77
00:05:29,340 --> 00:05:31,830
&nbsp;

78
00:05:31,830 --> 00:05:36,150
これはおそらく、あなた自身のカスタムラムダ式や関数を適用する能力のない最も強力な機能の1つです。

79
00:05:36,150 --> 00:05:38,280
&nbsp;

80
00:05:38,280 --> 00:05:42,680
もう一度Combsを取り除くことについて話しましょう。

81
00:05:42,690 --> 00:05:46,110
もし私たちが持っていれば、私たちは取り除いてみましょう。

82
00:05:46,120 --> 00:05:47,580
1列目。

83
00:05:47,580 --> 00:05:55,360
私たちは、ZFが描画する列をZFドロップすると言うことができます。

84
00:05:55,380 --> 00:06:00,250
次に、アクセスを指定する必要がある列上にあるので、1を覚えておいてください。

85
00:06:00,570 --> 00:06:04,070
そして、これがその場で発生したければ、このコラムを削除します。

86
00:06:04,200 --> 00:06:09,580
場所はtrueと等しくなければなりません。

87
00:06:09,720 --> 00:06:11,800
先に進んで、それを実行しないでください。

88
00:06:11,810 --> 00:06:17,790
したがって、データフレームから列名と索引名を取得する場合は、元のデータフレームを保持します。

89
00:06:18,090 --> 00:06:21,070
それらは実際にはデータフレーム自体の属性です。

90
00:06:21,370 --> 00:06:29,050
つまり、DF列は、このような種類の索引オブジェクトを基本的に列名のリストとして返すと言うことができます。

91
00:06:29,040 --> 00:06:29,800
&nbsp;

92
00:06:29,810 --> 00:06:34,930
これは、列のインデックスを作成しようとしているときや、スペースが奇妙な場合や、文字列が何であるか把握できない場合に特に役立ちます。

93
00:06:34,920 --> 00:06:37,500
&nbsp;

94
00:06:37,500 --> 00:06:40,940
DFAの列やデータフレーム名を呼び出してもかまいません。

95
00:06:41,040 --> 00:06:46,170
また、この列名のリストを返すと、インデックスに対して同じことを実際に行うことができます。

96
00:06:46,360 --> 00:06:49,540
DFAインデックスと言うと、インデックスの情報が表示されます。

97
00:06:49,770 --> 00:06:55,830
この場合は範囲​​索引であるため、実際にはインデックスの開始停止とステップサイズを戻すだけです。

98
00:06:55,830 --> 00:06:57,360
&nbsp;

99
00:06:57,370 --> 00:07:01,800
さて、データフレームの並べ替えと並べ替えについて話しましょう。

100
00:07:02,000 --> 00:07:07,880
ここでは深呼吸をして、2列目で並べ替えたいと考えています。

101
00:07:08,130 --> 00:07:13,890
本質的には、私たちが5 5 5と6 6を見る前に、再び4 4 4と4を求めます。

102
00:07:14,040 --> 00:07:17,330
これを行うためにソート値を使用することができます。

103
00:07:18,150 --> 00:07:22,750
あなたはDMF saurのアンダースコア値を呼び出しました。

104
00:07:22,920 --> 00:07:28,200
そして議論としてあなたは今ここでシフトタブをチェックしました。私たちはバイバイと言うことができ、あなたは行または列のいずれかからこれを注文することができます。

105
00:07:28,200 --> 00:07:32,280
&nbsp;

106
00:07:32,280 --> 00:07:36,910
しかし、本質的には、並べ替えたい列の引数としてPessinを使用するだけです。

107
00:07:36,960 --> 00:07:43,580
だから、私はこれを2列目でソートしたいと思っています。

108
00:07:43,600 --> 00:07:50,280
そして今、私は、列ごとにどのようにインデックスが行に付いているかを知るために、列ごとの状態を整理しています。

109
00:07:50,310 --> 00:07:52,520
だからあなたはそこでその情報を失うことはありません。

110
00:07:52,920 --> 00:07:59,220
これは、最初の引数であることを期待しているため、2列目の同じことだけを言っているのと同じことです。

111
00:07:59,230 --> 00:08:00,350
&nbsp;

112
00:08:01,020 --> 00:08:01,440
大丈夫。

113
00:08:01,830 --> 00:08:04,370
もっと便利な操作のほんのちょっと話しましょう。

114
00:08:04,530 --> 00:08:12,410
あなたのデータフレームで値が見つからないようにする本当に便利な方法は、DFTがnullで、値がnullであるかどうかを示すブール値のデータフレームを返します。

115
00:08:12,410 --> 00:08:17,940
&nbsp;

116
00:08:17,940 --> 00:08:23,340
この場合、私たちはデータフレームにヌルがあることを知っているので、すべての偽のブール値を取得します。

117
00:08:23,350 --> 00:08:23,730
大丈夫。

118
00:08:23,740 --> 00:08:29,690
最後にピボットテーブルと呼ばれるpantlessの最後の関数またはメソッドについて最後に説明します。

119
00:08:29,940 --> 00:08:33,890
この方法論は、Excelの高度なユーザーにはよく知られています。

120
00:08:34,000 --> 00:08:40,340
私は先に進んで、新しいデータフレームを作成するために、ノートブックからいくつかのコードをコピー＆ペーストします。

121
00:08:41,080 --> 00:08:44,210
私たちは外に出て、フレームの状態をチェックします。このようなものがあります。

122
00:08:44,250 --> 00:08:46,820
私たちはb cとdの列を持っています。

123
00:08:47,460 --> 00:08:54,010
ここで、A列B列とC列の両方で値を繰り返すことに注意してください。列にはFooがあり、Bには2つの値があります。

124
00:08:54,000 --> 00:08:57,850
&nbsp;

125
00:08:58,050 --> 00:09:04,950
CにはXがあり、賢明です。そしてDにはDFTピボットテーブルを使用できる整数値があります。

126
00:09:04,950 --> 00:09:09,600
&nbsp;

127
00:09:09,960 --> 00:09:15,120
&nbsp;

128
00:09:15,120 --> 00:09:15,760
ピボットテーブルを作成します.Pivotテーブルに慣れていない場合は、あまり心配する必要はありませんが、ピボットテーブルをよく知っているExcelユーザーであれば、この機能が役立ちます。

129
00:09:16,000 --> 00:09:21,810
基本的には、ユーザーに優秀ではない人にとっては、このテーブルまたはデータフレームから複数のインデックスを作成するだけです。

130
00:09:22,170 --> 00:09:23,940
&nbsp;

131
00:09:24,420 --> 00:09:33,600
これを行う方法は、アンダースコアテーブルとピボットアンダースコアテーブルに3つの主な引数をとり、インデックスとカラムの値を取ることです。

132
00:09:34,000 --> 00:09:37,450
&nbsp;

133
00:09:37,500 --> 00:09:43,050
この場合、テーブルに必要な値がこれらの値であることを示しておきましょう。

134
00:09:43,060 --> 00:09:44,250
これは私たちが実際に望むものです。

135
00:09:44,250 --> 00:09:47,270
データフレームデータポイントは、以下から構成されます。

136
00:09:47,280 --> 00:09:52,140
だから私は値がD列と等しいと言うつもりです。

137
00:09:53,040 --> 00:09:59,950
そして、私はインデックスをA列とB列に等しく設定します。基本的にaとbを多段階索引にします。

138
00:09:59,940 --> 00:10:03,200
&nbsp;

139
00:10:03,210 --> 00:10:09,760
乗客リストに行くのは、それが複数の列インデックスとBであるからです。

140
00:10:09,780 --> 00:10:14,950
最後に、私の実際の列をC列で定義します。

141
00:10:15,070 --> 00:10:21,810
このケースでは、私はそれをここのリストとして渡して、私はそれが列になると思うと言っていることに注意してください。

142
00:10:21,820 --> 00:10:22,320
&nbsp;

143
00:10:22,330 --> 00:10:25,860
だから、私はXの列とyの列になるはずです。

144
00:10:25,870 --> 00:10:28,360
これがどう動くか見てみましょう。

145
00:10:28,470 --> 00:10:34,390
ここでこれをもう一度実行して、元のデータフレームと作成しようとしているピボットテーブルを比較できます。

146
00:10:34,380 --> 00:10:36,930
&nbsp;

147
00:10:36,930 --> 00:10:38,970
よかったので、私はこのピボットテーブルコマンドを実行しました。

148
00:10:39,180 --> 00:10:41,220
そして、2つを比較してみましょう。

149
00:10:41,400 --> 00:10:47,580
&nbsp;

150
00:10:47,590 --> 00:10:54,780
&nbsp;

151
00:10:54,780 --> 00:10:58,410
これらの列とB列から作成された索引のように見えるので、字句的にバーとfooを作成し、次に実際の列を1つと2つ繰り返して、この場合の値XとYと実際のデータポイント値D列。

152
00:10:58,600 --> 00:11:03,820
いいえ、ここでは価値がないのは、その特定のポイントに一致する値がないからです。

153
00:11:04,200 --> 00:11:11,130
意味私は元のデータフレームを振り返ってみると、バーでxに行く価値はありません。

154
00:11:11,130 --> 00:11:16,130
あなたがここを見れば、あなたはXを捕まえることができません。 あなたはパート2 yだけを見つけるでしょう。

155
00:11:16,750 --> 00:11:19,550
同様に、食べ物はyです。

156
00:11:19,600 --> 00:11:25,850
なぜ食べ物がXにしかないのかという理由で食べ物はありません。そのため、ここでは値を記入しなければなりませんでした。

157
00:11:25,920 --> 00:11:26,500
OK。

158
00:11:26,560 --> 00:11:31,320
ピボットテーブルに関するご質問がある場合や、ピボットテーブルの例に関するリソースが必要な場合は、Q＆Aを投稿してください。

159
00:11:31,330 --> 00:11:32,950
&nbsp;

160
00:11:32,940 --> 00:11:34,870
コースで頻繁に使用することはありません。

161
00:11:34,870 --> 00:11:39,630
実際には、ピボットテーブルの使い方についてヒートマップを使って作業しているところで、実際には1つのエクササイズに関する質問しかありません。

162
00:11:39,630 --> 00:11:41,180
&nbsp;

163
00:11:41,250 --> 00:11:45,930
しかし、Excelのようなものから既によく知られているピボットテーブルの場合は、今は自分自身に心配してください。

164
00:11:46,000 --> 00:11:46,970
&nbsp;

165
00:11:47,110 --> 00:11:47,770
OK。

166
00:11:47,940 --> 00:11:50,100
これらの操作の一部があなたに役立つことを願っています。

167
00:11:50,130 --> 00:11:55,340
彼らは、便利な機能と方法のグラブバッグを見るだけで、あなたのパナで利用できます。

168
00:11:55,470 --> 00:12:01,440
panderersフォルダの下にあるpandas操作の講義ノートを参照して参照できます。

169
00:12:01,470 --> 00:12:02,510
&nbsp;

170
00:12:02,520 --> 00:12:04,580
みんなありがとう、私は次の講演で見ます
