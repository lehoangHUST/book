1
00:00:05,130 --> 00:00:06,000
みなさん、こんにちは。

2
00:00:06,000 --> 00:00:10,800
この講義を講義するための1日のcapstoneプロジェクトソリューションへようこそ。この講義では、夜間の解決策を検討していきます。

3
00:00:10,800 --> 00:00:13,850
&nbsp;

4
00:00:13,920 --> 00:00:16,710
外出して、木星のノートブックにジャンプして始めましょう。

5
00:00:16,800 --> 00:00:17,060
大丈夫。

6
00:00:17,070 --> 00:00:18,560
ここで私はノートブックにいます。

7
00:00:18,570 --> 00:00:20,730
進んで始めましょう。

8
00:00:20,730 --> 00:00:25,620
&nbsp;

9
00:00:25,630 --> 00:00:34,110
私がしたい最初のことは、私たちが外に出て重要な審判とPとPDをPDとし、次のセルがビジュアライゼーションライブラリをインポートし、マップパイロットをラインに設定するよう求めているとき、パイとパンダが重要です。

10
00:00:34,150 --> 00:00:35,370
&nbsp;

11
00:00:35,370 --> 00:00:39,610
これは少し漠然としたものでしたが、うまくいけば、それについて話していることを実感してください。

12
00:00:39,650 --> 00:00:50,700
LIBMAN seaborneなので、私は部分的に言うことができるがPIのプロットはPiazzi

13
00:00:50,700 --> 00:00:55,530
asabusとしてAsinusと言うことができる。そして私は外に出て何が並んでいるのか言うだろう。

14
00:00:55,530 --> 00:01:00,420
次に、このファイルをThe Fというデータフレームとして読み込みたいと考えました。

15
00:01:00,840 --> 00:01:09,750
だから、PDはC S Vを読んで、実際には9を呼び出してから、9が1つ見えるようにすることができます。これは、vが私たちが気にするファイルです。

16
00:01:09,840 --> 00:01:11,280
&nbsp;

17
00:01:11,290 --> 00:01:13,380
そして、我々はデータの情報をチェックしたい。

18
00:01:13,410 --> 00:01:15,980
だから情報。

19
00:01:16,950 --> 00:01:21,890
したがって、ここにはほぼ100000件のエントリがあり、合計9個の列があることがわかります。

20
00:01:21,990 --> 00:01:27,960
そして、実際にノートの中に列の記述が現れた後、DEAの頭をチェックしたいと思っています。

21
00:01:27,960 --> 00:01:29,000
&nbsp;

22
00:01:29,430 --> 00:01:33,280
そして、私たちは頭の中のメソッドを呼び出すだけでそれを行うことができます。

23
00:01:33,600 --> 00:01:37,710
&nbsp;

24
00:01:37,740 --> 00:01:45,480
そして、ここで私たちは地球の頭を持っているので、実際にLotusphereのようなものがあるかの感覚を得ることができます。タイトルには何らかのラベルがついています。そして結局は実際のタイトルイベントです。そして、タイムスタンプGWPがあります右にスクロールします。

25
00:01:45,480 --> 00:01:49,650
&nbsp;

26
00:01:49,770 --> 00:01:53,180
私たちには住所があります。

27
00:01:53,190 --> 00:01:58,480
次に、911通話のトップ5の郵便番号は何ですか？

28
00:01:58,770 --> 00:02:06,600
さて、私たちは先に進み、列をつかんで、実際にはこれとそれ以外の値のカウントを指定するか、すべての郵便番号のすべてのカウントを回すことができます。

29
00:02:08,240 --> 00:02:10,870
&nbsp;

30
00:02:10,920 --> 00:02:12,890
そして、私たちはトップ5を欲しいだけです。

31
00:02:13,140 --> 00:02:16,230
だから我々はそのシリーズから5を持っています。

32
00:02:16,230 --> 00:02:18,540
そしてここに私たちはトップ5の郵便番号を持っています。

33
00:02:18,570 --> 00:02:22,910
次に、911通話のトップ5郡のPWPは何ですか？

34
00:02:23,190 --> 00:02:32,400
あなたは非常に似たようなことをDWPのコールバリューのアカウントを指定してから5に向かうことができます。これにより、Merion

35
00:02:32,400 --> 00:02:36,910
Abbingtonなどの低い結果が得られます。 ここでタイトル欄といくつのユニークなタイトルコードがあるかを見てみましょう。

36
00:02:37,500 --> 00:02:43,000
&nbsp;

37
00:02:43,230 --> 00:02:51,920
&nbsp;

38
00:02:51,920 --> 00:02:58,980
これを行うには2つの方法があります。タイトルの呼び出しでユニークな監査を呼び出すことができ、すべてのユニークなタイトルの配列を返すことは、ミニコンがその配列の長さをチェックして番号を取得すること、またはすべてをワンステップで行うことを意味します。

39
00:02:58,980 --> 00:03:00,500
あなたはただ呼び出すことができ、ユニークです。

40
00:03:00,540 --> 00:03:03,440
彼らはまた110を返します。

41
00:03:03,450 --> 00:03:06,060
OKをクリックして、titles列に新しい機能をいくつか作成します。

42
00:03:06,090 --> 00:03:09,750
タイトルコードの前にDepartmentのコードをスラッシュする理由があります。

43
00:03:09,780 --> 00:03:14,540
そして、これらはM-Sの火災と交通です。

44
00:03:14,700 --> 00:03:17,260
&nbsp;

45
00:03:17,430 --> 00:03:23,340
カスタム土地式を適用して、文字列値を含むreasonという新しい列を作成します。

46
00:03:23,430 --> 00:03:25,050
&nbsp;

47
00:03:25,050 --> 00:03:31,260
例えば、タイトル欄がM-Sの場合、最後の負傷であった場合、その値の理由列はM-Sとなります。頭を振り返ります。

48
00:03:31,260 --> 00:03:35,310
私が前に言及したように、ここにコロンがある種の理由があります。

49
00:03:35,700 --> 00:03:38,690
そして、完全なタイトルM-Sの火。

50
00:03:38,700 --> 00:03:41,180
その後、トラフィックが発生します。

51
00:03:41,190 --> 00:03:43,830
applyを使用してこの理由列を作成してみましょう。

52
00:03:44,130 --> 00:03:48,030
まず、外出して、私たちがしたいことの論理を打破しましょう。

53
00:03:48,240 --> 00:03:51,000
私はタイトルから例をつかむつもりです。

54
00:03:51,000 --> 00:03:55,530
&nbsp;

55
00:03:55,590 --> 00:04:03,570
私はそれが私がそれをするのが好きなやり方のようなものだと見て、これをXとして設定し、実際にここでこのタイトルをつかむためにXに何をしなければならないかを見てください。

56
00:04:03,570 --> 00:04:07,090
これは文字列なので、コロンで区切って言うことができます。

57
00:04:07,350 --> 00:04:13,190
そして、私はそのリストから最初の要素を取り除くだけで、タイトルが常に最初に来ることに気付きます。

58
00:04:14,070 --> 00:04:19,020
&nbsp;

59
00:04:19,020 --> 00:04:19,680
今私はこの理由があります。

60
00:04:19,680 --> 00:04:22,220
大丈夫。

61
00:04:22,330 --> 00:04:22,720
これは私たちがやることです。

62
00:04:22,770 --> 00:04:23,970
&nbsp;

63
00:04:23,970 --> 00:04:31,590
&nbsp;

64
00:04:32,440 --> 00:04:43,980
Ferland式は、列の理由を作成するためにそれがtitle列と同じに設定されていることを示し、次にlambdaとtitleと言うと、コロンのタイトルに基づいて分割され、次に最初の項目を取得しますそのリスト。

65
00:04:43,980 --> 00:04:48,200
どんな理由があるかを調べてみましょう。

66
00:04:48,210 --> 00:04:52,220
そして、それは私たちがメルズの火事であるように見えます。

67
00:04:53,810 --> 00:04:56,790
完璧。

68
00:04:56,790 --> 00:04:58,550
大丈夫。

69
00:04:58,560 --> 00:04:59,070
&nbsp;

70
00:04:59,370 --> 00:05:05,730
うまくいけば、それはあまりにも難しいことではない土地の表現を表現するために少しトリッキーにすることができますこれは良いヒントを適用します。

71
00:05:05,730 --> 00:05:06,770
&nbsp;

72
00:05:06,870 --> 00:05:11,700
例をつかんで、あなたがその例にしなければならないことを見て、これを土地表現に変換してください。

73
00:05:11,700 --> 00:05:13,380
&nbsp;

74
00:05:13,380 --> 00:05:16,890
今私たちはあなたのために最も一般的な理由が何であるかを知りたいと思います。私はこの新しいコラムに基づいて電話したくありません。

75
00:05:16,890 --> 00:05:18,420
それは実際にはかなり簡単です。

76
00:05:18,420 --> 00:05:19,570
&nbsp;

77
00:05:19,590 --> 00:05:29,580
EMIを返す理由値のカウントを呼び出すことができます。あなたがただ一つ持っていて、それがMSを返すと言える最も一般的な理由だけを返そうとするなら、最も一般的な理由ですが、我々は3つの値だけを示しますそのうちの。

78
00:05:29,880 --> 00:05:35,310
&nbsp;

79
00:05:35,310 --> 00:05:38,660
次に、私たちは海軍を使って9つの理由の1つの対抗策を作りたがっていました。

80
00:05:38,670 --> 00:05:44,700
OK。

81
00:05:44,790 --> 00:05:45,340
私たちはAsinusの反プロットと言うつもりで、次にx軸をここに理由を指定したいと思うでしょう。

82
00:05:45,720 --> 00:05:52,950
&nbsp;

83
00:05:53,080 --> 00:06:00,660
だから、私がXが理由だと言うと、カウンタープロットのためにはYはありません.Yは自動的にちょうどカウントに選ばれます。

84
00:06:00,660 --> 00:06:02,400
だから我々はデータがあると言うつもりです。

85
00:06:02,400 --> 00:06:03,820
そして、これを実行します。

86
00:06:03,930 --> 00:06:06,120
そしてここに私達のカウントプロットがあります。

87
00:06:06,120 --> 00:06:08,440
ソリューションブックに示されているように正確な色分けをしていないと心配しないでください。

88
00:06:08,940 --> 00:06:12,830
それはパレット上のちょっと余分な呼び出しです。

89
00:06:12,930 --> 00:06:15,170
&nbsp;

90
00:06:15,180 --> 00:06:23,160
だからパレットのようなことをすることができますし、ソリューションのために私が使用したのはこれのちょうど下にあり、色を少し変えます。

91
00:06:24,150 --> 00:06:25,340
しかし、上または上の色のマッチングについて心配しないでください。

92
00:06:25,350 --> 00:06:27,600
これは、選択肢ごとにオプションのカラーマッピングのようなものです。

93
00:06:27,610 --> 00:06:30,100
&nbsp;

94
00:06:30,150 --> 00:06:34,380
うまくいけば、カウント・プロットが理由と等しいこと、そしてそれがfをカウント・プロットを作成する上で最も重要な部分であることがわかりました。

95
00:06:34,380 --> 00:06:37,160
さあ、時間情報に注目しましょう。

96
00:06:37,170 --> 00:06:40,140
タイムスタンプ内のオブジェクトのデータ型は何を呼び出しますか？

97
00:06:40,200 --> 00:06:43,900
&nbsp;

98
00:06:43,920 --> 00:06:51,780
&nbsp;

99
00:06:51,780 --> 00:06:57,510
あなたができることはDFT情報を呼び出すことだけです。タイムスタンプを見れば、それはオブジェクト型であり、この種のものは数字ではなく実際には文字列であるというヒントを与えます。

100
00:06:57,510 --> 00:06:58,790
&nbsp;

101
00:06:58,950 --> 00:07:06,270
そして、私たちがこれらのオブジェクトの一つをつかんで、タイムスタンプを言うことができることを確認したいなら、ILOのC02は最初のものをスクラブし、文字列を返すことに注意してください。

102
00:07:06,360 --> 00:07:09,920
私たちは、タイプを言うことができ、ここでは文字列のTRとして持つことをさらに確認する必要があります。

103
00:07:09,930 --> 00:07:16,920
何かを知っているならば、あなたは一番上に行くだけです。

104
00:07:16,920 --> 00:07:19,820
これはここで文字列変数で確認されます。

105
00:07:19,860 --> 00:07:23,450
OKガンは転がります。

106
00:07:23,760 --> 00:07:26,310
だから私たちは時代の情報を持っていることを知っていますが、実際は文字列です。

107
00:07:26,310 --> 00:07:29,980
今度は、これらのタイムスタンプを日付オブジェクトに変換する必要があります。

108
00:07:30,300 --> 00:07:35,180
私たちはPDを使ってこれをやりたいのですが、このリンクをクリックすることができます。

109
00:07:35,270 --> 00:07:39,500
ここでは、日付の時間を強調するのに使用する方法に関するドキュメントにリンクすることに注意してください。

110
00:07:39,630 --> 00:07:44,040
&nbsp;

111
00:07:44,040 --> 00:07:48,150
&nbsp;

112
00:07:48,150 --> 00:07:58,980
先ほどの例を調べてみてください。実際には非常に単純な呼び出しなので、うまくいけばわかりましたが、基本的には、このケースをタイムスタンプに変換する列を渡すことをPDに伝えています。

113
00:07:58,980 --> 00:08:02,420
そして、私はその列をこれと等しくなるようにリセットするつもりです。

114
00:08:03,270 --> 00:08:10,610
そして、私が先に進むと、ここでこのコードを見てみましょう。

115
00:08:11,010 --> 00:08:15,180
コピーして貼り付けます。

116
00:08:15,210 --> 00:08:17,410
今私は正確に私たちが望むタイムスタンプオブジェクトを持っています。

117
00:08:17,460 --> 00:08:20,580
これは現在のDate Timeオブジェクトです。

118
00:08:20,580 --> 00:08:22,700
大丈夫。

119
00:08:22,710 --> 00:08:23,030
&nbsp;

120
00:08:23,040 --> 00:08:29,130
これで、日時オブジェクトまたはパンダのタイムスタンプで、オブジェクトを呼び出すことによってオブジェクトの特定の属性を実際に把握できるようになりました。

121
00:08:29,160 --> 00:08:31,190
そしてここにサンプルコードの小さな断片があります。

122
00:08:31,380 --> 00:08:35,240
私はこのサンプルコードをコピー＆ペーストするだけです。

123
00:08:35,400 --> 00:08:38,990
&nbsp;

124
00:08:39,030 --> 00:08:44,520
これを実行して実際に情報を取得できることを示し、Jupiterのtabメソッドを使用して呼び出すことができるさまざまな属性を調べるようにしています。

125
00:08:44,520 --> 00:08:47,540
&nbsp;

126
00:08:47,760 --> 00:08:53,460
そして今、時間列または実際にオブジェクトが使用する日付オブジェクトを使用して、月と曜日という3つの新しい列を作成します。

127
00:08:53,520 --> 00:08:55,590
&nbsp;

128
00:08:55,770 --> 00:09:00,270
タイムスタンプ列に基づいてこれらの列を作成し、それに固執して解決策を参照することができます。

129
00:09:00,270 --> 00:09:01,630
私を行かせて、もう少しこれを打ち破ろう。

130
00:09:01,800 --> 00:09:04,300
しかし、先を見て、何時が時間かを見てください。

131
00:09:04,440 --> 00:09:07,340
これは、このタイムスタンプの列の最初のエントリです。

132
00:09:07,350 --> 00:09:10,330
いいえ、タイムスタンプを言う。

133
00:09:10,340 --> 00:09:11,660
2015 12 10分時秒で秒。

134
00:09:11,800 --> 00:09:15,580
私はドットをつけ、このオブジェクトの属性を呼び出します。

135
00:09:15,620 --> 00:09:19,220
注意実際の年を知りたい場合は、インスタンスと呼ぶことができるさまざまな属性があります。

136
00:09:19,240 --> 00:09:24,840
&nbsp;

137
00:09:24,870 --> 00:09:32,010
これは私が年を呼び出し、2015年として報告することができるので、私はそれが何時だったか知りたいと思っています。

138
00:09:32,010 --> 00:09:33,190
それを1700時間として報告します。

139
00:09:33,230 --> 00:09:35,650
&nbsp;

140
00:09:35,650 --> 00:09:41,490
だから、軍隊や24時間形式で、今月に入っていた月を知りたければ、曜日のようなものを呼び出すこともできるので、曜日は3です。

141
00:09:41,720 --> 00:09:47,390
そして、後で実際にあなたが参照するための辞書がここにあります。

142
00:09:47,400 --> 00:09:51,800
大丈夫。

143
00:09:51,810 --> 00:09:52,170
&nbsp;

144
00:09:52,170 --> 00:09:57,900
今度は、クライアントのこの機能をオフにして、実際に月と曜日の列に実際に作成する同じ列を作成して、それをどのように行うのかを示します。

145
00:09:57,900 --> 00:10:02,770
たとえば、半時間がタイムスタンプの列のdieaに等しいとします。

146
00:10:02,790 --> 00:10:12,580
そして、我々は、ラムダが時間をとり、時間属性を返すと言っていることを適用すると言うつもりです。

147
00:10:13,370 --> 00:10:23,390
&nbsp;

148
00:10:24,260 --> 00:10:30,300
&nbsp;

149
00:10:30,300 --> 00:10:36,150
私たちはそこに入り、それを実行して、今私たちの属性をチェックすると、実際の呼び出しがタイムスタンプから外されたすべての時間があり、私たちは月と曜日にまったく同じことに行きます。

150
00:10:36,150 --> 00:10:36,500
&nbsp;

151
00:10:36,540 --> 00:10:42,480
&nbsp;

152
00:10:42,480 --> 00:10:49,080
実際には、このコード行をコピーして貼り付けることができます。まず最初に、月に入れてこの属性を月の呼び出しに変更し、2番目のものを先に呼び出して呼び出しますこの曜日に変更してから、これを曜日のコールの曜日に変更します。

153
00:10:49,080 --> 00:10:50,820
&nbsp;

154
00:10:53,730 --> 00:10:58,670
今度はこれを実行します。

155
00:10:58,770 --> 00:11:02,100
今すぐデータフレームの先頭をチェックして、これがすべて機能していることを確認してください。

156
00:11:02,100 --> 00:11:06,630
ここで適切な通知までスクロールすると、3つの新しい列があります。

157
00:11:06,920 --> 00:11:11,980
私たちは月と曜日を持っており、数字がいくつか存在しています。

158
00:11:11,990 --> 00:11:16,330
&nbsp;

159
00:11:16,740 --> 00:11:23,910
&nbsp;

160
00:11:23,910 --> 00:11:31,730
OKを次に覚えておきたいのは、曜日が0から6までの整数で、実際の文字列名をここで行う必要がある曜日にマップするためにこの辞書でドットマップメソッドを使用するということです。

161
00:11:31,740 --> 00:11:32,600
このコード行をコピーしてください。

162
00:11:32,610 --> 00:11:36,390
&nbsp;

163
00:11:36,450 --> 00:11:44,590
今私たちは地図を持っているだけで、IFの曜日がf日と等しいと言うことを見て、あなたが実際にここで言及している方法であるその地図を言うことができます。

164
00:11:44,590 --> 00:11:51,290
そして、地図を渡してください。

165
00:11:51,600 --> 00:11:55,370
&nbsp;

166
00:11:55,410 --> 00:11:58,050
&nbsp;

167
00:12:01,050 --> 00:12:06,800
そして今、私たちがデータフレームの先頭をチェックすると、右にスクロールして再び週の曜日が実際の文字列である木曜日〜金曜日の序列になります。

168
00:12:06,900 --> 00:12:07,380
だから、少し読みやすくなります。

169
00:12:07,450 --> 00:12:09,920
OK。

170
00:12:10,580 --> 00:12:10,990
&nbsp;

171
00:12:11,070 --> 00:12:16,140
今度はもっと見ることができ、理由の列に基づいた色相で曜日の列のカウンタープロットを作成します。

172
00:12:16,140 --> 00:12:18,090
それを再現しましょう。

173
00:12:18,090 --> 00:12:19,320
&nbsp;

174
00:12:19,320 --> 00:12:27,480
Asinusの対立プロットXが列データの日になると言うことができます。

175
00:12:30,450 --> 00:12:33,300
私たちは1週間で渡す必要はなく、数えてカウントする必要はないことを忘れないでください。

176
00:12:33,330 --> 00:12:36,010
これを行うだけで、1日の合計カウントが取得されます。

177
00:12:36,240 --> 00:12:41,340
&nbsp;

178
00:12:41,400 --> 00:12:47,370
だから、日曜日には、Heughが色相が理由であると指定し、これらのソリューションに示されているプロットのレクリエーションを追加することができます。

179
00:12:47,370 --> 00:12:53,060
ここで注意すべき点は、カラーパレットが少し違うことです。

180
00:12:53,070 --> 00:12:56,870
私がしたのと同じカラーパレットを使用したい場合。

181
00:12:56,980 --> 00:12:58,850
あなたは先に進み、紫色のパウチと言い、同じカラーパレットを再現することができます。

182
00:12:58,890 --> 00:13:08,250
最後に、伝説は実際にここに入っていて、解決のために伝説を再配置したいということです。

183
00:13:08,370 --> 00:13:13,680
&nbsp;

184
00:13:13,680 --> 00:13:15,370
&nbsp;

185
00:13:15,540 --> 00:13:21,240
実際には、Seabornの講義中に行ったのと同じコードをコピーして貼り付けるだけで、凡例を外に置く方法を実際に示すことができます。

186
00:13:21,240 --> 00:13:24,020
私たちはそれを実行するつもりです。

187
00:13:24,120 --> 00:13:25,180
今私たちはプロット自体の外に伝説を持っています。

188
00:13:25,260 --> 00:13:28,600
大丈夫。

189
00:13:28,620 --> 00:13:29,010
今私たちが実行しなければならなかった次の作業は月の列について同じでした。

190
00:13:29,010 --> 00:13:33,260
&nbsp;

191
00:13:33,540 --> 00:13:42,870
基本的には、このコードをコピー＆ペーストしてxを月に変更するだけで、それは月の列を除いて全く同じプロットになります。次の質問がありました。プロット。

192
00:13:42,870 --> 00:13:47,700
&nbsp;

193
00:13:47,700 --> 00:13:49,950
そして、うまくいけば、あなたは実際に何ヶ月も行方不明になっていることに気づくでしょう。

194
00:13:50,100 --> 00:13:53,340
それは1つから8つになりますが、あなたは9 10と11の月がありません。

195
00:13:53,430 --> 00:13:57,590
彼らはまっすぐ12歳になる。

196
00:13:57,660 --> 00:14:00,030
&nbsp;

197
00:14:00,270 --> 00:14:05,820
&nbsp;

198
00:14:05,850 --> 00:14:11,400
だから今私たちがやりたいかもしれない情報が欠落していることに気づいたのは、情報を別の方法でプロットすることです。欠落した月を埋める単純な線図を使って、できるだけ追加作業をする必要がありますパンダと一緒に。

199
00:14:11,400 --> 00:14:14,440
&nbsp;

200
00:14:14,490 --> 00:14:20,250
この問題を解決しようとするために、ここではソリューション講義の第1部を開始し、第2部では月単位のオブジェクト別グループを作成します。

201
00:14:20,250 --> 00:14:24,660
はい。

202
00:14:24,660 --> 00:14:25,160
みなさん、ありがとうございます。次の講演でお会いしましょう。

203
00:14:25,410 --> 00:14:27,280
ソリューションの第2部

204
00:14:27,280 --> 00:14:28,710
&nbsp;
