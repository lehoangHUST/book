1
00:00:05,370 --> 00:00:10,070
こんにちは皆さん、夜のためにいくつかのプロジェクトソリューション講義を取り上げるために、2日のパート2へようこそ。

2
00:00:10,100 --> 00:00:12,040
1つが棺のプロジェクトを呼び出すとき。

3
00:00:12,240 --> 00:00:15,840
私たちが中断して木星のノートに行くところで右に飛びましょう。

4
00:00:16,290 --> 00:00:21,270
&nbsp;

5
00:00:21,270 --> 00:00:27,180
&nbsp;

6
00:00:27,180 --> 00:00:32,190
ここでOKです私はノートブックの右側にありました。私たちは、9月と9月の間に数ヶ月間価値が失われていることを発見しました。10と11がなくなってしまったので、今はパンダを使ってラインプロットを作成しようとします。それを考慮に入れようとする他の視覚化。

7
00:00:32,220 --> 00:00:34,700
だから、それらの欠けているデータポイントを埋めることができるかもしれません。

8
00:00:35,140 --> 00:00:35,630
OK。

9
00:00:35,700 --> 00:00:44,670
私たちは先に進むつもりですが、月ごとに呼び出されるオブジェクト別にグループを作成し、DMFグループに、月の列を渡して、集計に使用方法を指示して指示します。

10
00:00:44,670 --> 00:00:51,740
&nbsp;

11
00:00:51,780 --> 00:00:52,490
そして、それは先に進んでいた。

12
00:00:52,490 --> 00:00:54,540
ただの頭をチェックしてください。

13
00:00:54,570 --> 00:00:56,050
月ごと。

14
00:00:56,590 --> 00:00:58,040
OKとここで私たちの頭を見ることができます。

15
00:00:58,050 --> 00:01:04,500
&nbsp;

16
00:01:04,500 --> 00:01:10,680
月ごとに、実際に何が起こったかは、月ごとに列の各インスタンスを数えたか、または先に進む予定であり、実際の列の値によって数が異なることに気づくでしょう。

17
00:01:10,740 --> 00:01:13,140
&nbsp;

18
00:01:13,180 --> 00:01:15,900
そして、それは本質的に欠けている価値があるからです。

19
00:01:15,960 --> 00:01:18,590
あなたが月ごとにそれを集めるとき、私たちは前進して行います。

20
00:01:18,600 --> 00:01:19,860
また、すべてが出ているわけでもありません。

21
00:01:19,890 --> 00:01:24,050
集計カウントの値として緯度の列を選択するだけです。

22
00:01:24,120 --> 00:01:29,980
さて、私たちが電話の緯度を持っていれば、実際に電話がかかったと仮定します。

23
00:01:30,000 --> 00:01:34,660
&nbsp;

24
00:01:34,670 --> 00:01:42,060
今度は、月額コストのカウントを示すデータフレームの簡単なプロットを作成して、実際には月単位で列をプロットして、たとえば緯度などの列を呼び出してプロットするというだけのことができます。

25
00:01:42,150 --> 00:01:45,750
&nbsp;

26
00:01:46,530 --> 00:01:51,240
そしてここに私たちの月があり、実際には、欠けている情報のいくつかを、本質的に12時のポイント・ポイントとポイントの間のフィット感で埋めることができました。

27
00:01:51,660 --> 00:01:55,960
&nbsp;

28
00:01:56,040 --> 00:02:00,260
そして、ダウンカーブがあなたのできるよりも少し良いかもしれません。

29
00:02:00,450 --> 00:02:06,210
&nbsp;

30
00:02:06,240 --> 00:02:14,430
&nbsp;

31
00:02:14,490 --> 00:02:17,460
ちょうど棒のプロットでそれをやったことがありますか、少し詳しく説明しておきます。私はこのコードをここに貼り付けてコピーします。私は先に進んで姫を取り除きます。これを実行すると、コードが表示されます。

32
00:02:17,460 --> 00:02:18,900
ここには月があります。

33
00:02:18,900 --> 00:02:20,800
この小さな警告を心配しないでください。

34
00:02:21,090 --> 00:02:23,340
しかし、これは基本的に同じ情報を示しています。

35
00:02:23,340 --> 00:02:25,670
しかし、9 10 11月なし。

36
00:02:25,840 --> 00:02:31,650
だから、7ヶ月目の2ヶ月間の8時間と12時間目からのドロップダウンを見ることができます。

37
00:02:31,650 --> 00:02:33,050
たぶんもう少し明確になっているかもしれません。

38
00:02:33,100 --> 00:02:37,060
この種のラインプロットを使用して8〜12の間にドロップダウンします。

39
00:02:37,380 --> 00:02:42,450
&nbsp;

40
00:02:42,750 --> 00:02:50,220
そして、実際には、郷の列やジップの列など、どの列をプロットして遊んだりすることができます。このドロップがどのように探索的なデータ分析のようなものか、まったく正しい答えがない定量的な方法で非常に具体的に何かを見せたいと思っています。その場合、おそらくこの種のバープロットが表示されます。

41
00:02:50,250 --> 00:02:56,430
&nbsp;

42
00:02:56,430 --> 00:03:01,050
&nbsp;

43
00:03:01,050 --> 00:03:06,540
しかしこの単純なプロットコマンドを使ってトレンドを知るだけでいいのです。

44
00:03:06,540 --> 00:03:06,960
大丈夫。

45
00:03:07,320 --> 00:03:11,850
今すぐに進み、L-Mプロットを使って1か月あたりのコール数に線形近似をつくることができるかどうかを見てみましょう。

46
00:03:11,850 --> 00:03:13,000
&nbsp;

47
00:03:13,050 --> 00:03:17,750
そして、そのためにインデックスを列にリセットする必要があるかもしれないことに留意してください。

48
00:03:17,790 --> 00:03:20,870
私が外出してやることは、これを言うことです。

49
00:03:20,880 --> 00:03:27,330
私はSと言うつもりです。 A. L. M.

50
00:03:27,330 --> 00:03:35,420
Seabornからの線形モデルプロットのプロット。私が外に出てこれを月にチェックすると私のXが必要になり、私たちは今y軸の多分町のシップを選択することができます。

51
00:03:35,520 --> 00:03:39,690
このように本質的にちょうどカウントする実験の種類にしたい場合は、緯度または実際に他の列を選択することもできます。

52
00:03:39,690 --> 00:03:42,460
&nbsp;

53
00:03:43,680 --> 00:03:48,860
そして、データは月ごとに表示されます。

54
00:03:49,950 --> 00:03:52,890
しかしここに注目すると、私はXが月の列だと言った。

55
00:03:52,890 --> 00:04:00,480
私たちが実際に月の列を持っていない月を振り返ってみると、その月が指数でした。

56
00:04:00,570 --> 00:04:05,370
だから私がやるべきことは、これを働かせるためにインデックスを月にリセットして、それをさらに明確にすることです。

57
00:04:08,770 --> 00:04:11,070
&nbsp;

58
00:04:11,070 --> 00:04:15,720
これが実際にどのように見えるかを私に教えてください。

59
00:04:16,350 --> 00:04:21,750
インデックスをリセットしたり、月を新しい列にすると、Seabornはインデックスに設定する代わりにこの情報に実際にアクセスすることができます。

60
00:04:21,750 --> 00:04:26,630
&nbsp;

61
00:04:26,880 --> 00:04:29,110
そして、私は実際に渡すことができ、月はここに文字列です。

62
00:04:29,130 --> 00:04:31,200
さもなければシーボーンは混乱するだろう。

63
00:04:31,290 --> 00:04:39,060
&nbsp;

64
00:04:39,060 --> 00:04:43,980
それで、この最近のインデックスを列に使う必要があったのですが、線形モデルにフィットするようになりました。そして、このモデルではSeymoreがどのような種類のものであるかを見ると、コール数が0から月12。

65
00:04:43,980 --> 00:04:47,640
&nbsp;

66
00:04:47,640 --> 00:04:52,850
シーボーンは、これが月であることを認識するのに十分な情報がないことに注意してください。

67
00:04:52,980 --> 00:04:57,380
そして、13と14は実際には存在してはいけません。

68
00:04:57,420 --> 00:05:01,800
&nbsp;

69
00:05:01,890 --> 00:05:07,530
&nbsp;

70
00:05:07,560 --> 00:05:12,360
&nbsp;

71
00:05:12,360 --> 00:05:15,540
これは実際には季節データであり、その場合はおそらく線形モデルが実際に最適であり、海面のある国ではこれを示すこの陰影のある領域でエラーが表示され、エラーが基本的に増えますこれは実際には10か月か11か月の情報を持っていることに多くの意味があります。

72
00:05:15,900 --> 00:05:21,770
そして、この傾向が下がってくるのを見ることができます。その後、8か月間にクラッシュすると、後でデータで調べることができます。

73
00:05:21,870 --> 00:05:24,540
&nbsp;

74
00:05:24,540 --> 00:05:30,170
さて、今のところそれを残して、日付情報についてもう少し詳しく調べてみましょう。

75
00:05:30,930 --> 00:05:31,210
OK。

76
00:05:31,220 --> 00:05:36,920
次は、タイムスタンプ列の日付を含むdateという新しい列を作成し、date close

77
00:05:36,930 --> 00:05:42,590
closehesesメソッドとともにapplyを使用する必要があります。

78
00:05:42,600 --> 00:05:50,460
タイムスタンプの列の例を示すことで、これが実際に日付で何を意味するのかを紹介しましょう。

79
00:05:50,460 --> 00:05:51,790
&nbsp;

80
00:05:51,920 --> 00:05:58,860
私は先に進んで、タイムスタンプ列の最初のインスタンスを取得し、それらのオブジェクトの1つを呼び出します。

81
00:05:58,880 --> 00:06:00,000
&nbsp;

82
00:06:00,010 --> 00:06:00,320
大丈夫。

83
00:06:00,320 --> 00:06:06,180
これはタイムスタンプオブジェクトであり、実際には日付オブジェクトとは少し異なります。

84
00:06:06,240 --> 00:06:13,520
そして、その理由は、私はそれの日付を呼び出す場合、私は今、日付オブジェクトを取得します。

85
00:06:13,530 --> 00:06:15,750
そして、これは日付情報を表示するだけです。

86
00:06:15,750 --> 00:06:20,940
それはもはや時間情報を持っていません。それは後でやってみたいことは、日付ごとの呼び出し数だけのようなプロットを作成することです。

87
00:06:20,940 --> 00:06:25,440
&nbsp;

88
00:06:25,440 --> 00:06:31,760
私たちは毎分毎分彼女の呼び出しの数でこの情報を洪水させたくありません。

89
00:06:31,750 --> 00:06:32,400
大丈夫。

90
00:06:32,670 --> 00:06:45,060
つまり、ZF dateがタイムスタンプのDMFに等しいといってみましょう。

91
00:06:45,180 --> 00:06:49,760
&nbsp;

92
00:06:49,760 --> 00:06:55,320
そして、私が前にしたように、私はこのFil-Amを使って、その時を見て、その日に戻って帰ってくる表現を適用します。

93
00:06:55,350 --> 00:06:57,620
私は先に進み、それを適用する。

94
00:06:57,620 --> 00:07:05,490
今私はZFの頭部を見て、ここまで右に行くならば。

95
00:07:05,610 --> 00:07:11,330
今私はこのタイムスタンプの列から追い出されたこの素敵な日付の列を持っています。そして、私が先に進みたいときに、カウントの集計で状態の列にグループ化されます。

96
00:07:11,370 --> 00:07:16,340
&nbsp;

97
00:07:16,430 --> 00:07:18,590
だから私はdiff日付を言うつもりです。

98
00:07:18,670 --> 00:07:19,070
うわー。

99
00:07:19,110 --> 00:07:24,350
実際に私はDFAグループを合格期限までにお伝えしたいと思います。

100
00:07:24,360 --> 00:07:26,380
それは私が購入したいものです。

101
00:07:26,460 --> 00:07:32,270
私は先に進もうと思っています。そして、ちょうど入り込んで、フレームの状態の頭部を見てみましょう。

102
00:07:32,270 --> 00:07:33,760
&nbsp;

103
00:07:34,470 --> 00:07:35,150
OK。

104
00:07:35,250 --> 00:07:41,090
そして、これは本質的に、発生した実際の日付の彼女の日付をすべてカウントします。

105
00:07:41,100 --> 00:07:46,440
&nbsp;

106
00:07:46,470 --> 00:07:53,130
&nbsp;

107
00:07:53,150 --> 00:07:55,020
もう一度、これらの列の値のいくつかの違いがあることに気付くと、ちょうど基本的には、12月11日の96回のコールのうち300件の情報が欠落していたことを示しています。

108
00:07:55,130 --> 00:08:03,590
まだ12月11日であるかどうかに関わらず、あなたは郵便番号で333人でしたが、緯度は396人でした。

109
00:08:04,560 --> 00:08:07,440
これらの列の1つを選択してみましょう。

110
00:08:07,440 --> 00:08:12,810
&nbsp;

111
00:08:13,640 --> 00:08:21,120
実際には数値に近いので任意のものですが、私は先に進んで緯度の列をつかんで、それらを比較する方法を異なる列でつかむことで実験できます。

112
00:08:21,120 --> 00:08:26,430
ここでは、基本的に私に緯度を知っていた呼び出しの数をカウントして、次に進めることができる緯度の列があります。

113
00:08:26,430 --> 00:08:29,740
&nbsp;

114
00:08:29,740 --> 00:08:33,880
ちょうどこれをプロットすると、それは私にこのようなプロットを取得します。

115
00:08:33,960 --> 00:08:41,340
そして、これらのラベルの一部が重なっていることに注目してください。私たちができることは、実際にはそのインデックスを修正し、少し上手くいくものを得るために前に示したように、

116
00:08:41,340 --> 00:08:46,710
&nbsp;

117
00:08:47,460 --> 00:08:48,200
大丈夫。

118
00:08:48,210 --> 00:08:52,980
&nbsp;

119
00:08:53,300 --> 00:08:59,270
そして、実際にここに気付くと、2月にはかなりのスパイクがあり、3月には少しのスパイクがあるように見えますが、5月と8月下旬にスパイクが激減します。

120
00:08:59,310 --> 00:09:00,020
&nbsp;

121
00:09:00,020 --> 00:09:01,520
ここでは少し難しいです。

122
00:09:01,950 --> 00:09:06,720
そして、あなたは先に進んでこのプロットを混乱させたり、実際の日付についてもう少し詳しい情報を得るようにプロットを拡張することができます。

123
00:09:06,720 --> 00:09:08,170
&nbsp;

124
00:09:08,510 --> 00:09:13,230
さて、私たちは先に進んで、このプロットを作り直して、それぞれのプロットが911呼び出しの理由を表す3つの別々のプロットを作成します。

125
00:09:13,230 --> 00:09:15,950
&nbsp;

126
00:09:16,010 --> 00:09:22,120
理由のデータフレームに戻って、または私がそれが意味するものをミシュと呼んで私は言い訳をします。

127
00:09:22,480 --> 00:09:25,100
だからここをスクロールすると、私はこのプロットを再現したい。

128
00:09:25,160 --> 00:09:31,420
&nbsp;

129
00:09:32,820 --> 00:09:39,120
だからここでは、交通だけで火災の呼び出しをしてからM-Sの呼び出しだけを使って1つのプロットをしています。私たちは、実際にはここで行ったことと非常に似たプロセスです。

130
00:09:40,190 --> 00:09:45,480
これをコピーして貼り付けますが、データフレーム全体の代わりに、条件付き選択を使用してグループを実際に実行します。

131
00:09:45,480 --> 00:09:48,790
&nbsp;

132
00:09:49,350 --> 00:09:52,760
&nbsp;

133
00:09:55,500 --> 00:10:03,150
&nbsp;

134
00:10:03,140 --> 00:10:09,880
&nbsp;

135
00:10:09,880 --> 00:10:17,020
&nbsp;

136
00:10:17,020 --> 00:10:19,810
だから私はATFの理由が最初のものと等しいDSFを言うつもりですが、そこで私たちにトラフィックを伝え、次にこれをプロットしてそこにトラフィックをプロットして、あなたが望むならタイトルにアピールすると言っているかもしれませんし、あなたがタイトルをトラフィックにしたいと指示したので、実際には同じコードを使って他のチャートを実行することができます。

137
00:10:19,810 --> 00:10:24,450
だから私たちが火を求めていたならば、それを理由として火に置き換えました。

138
00:10:25,000 --> 00:10:30,610
そして今、私たちは、これらの3つの別々のプロットを作成するために以前に行ったすべての作業を利用することができます。

139
00:10:30,610 --> 00:10:31,390
&nbsp;

140
00:10:31,390 --> 00:10:35,770
&nbsp;

141
00:10:35,830 --> 00:10:41,050
そしてあなたは先に進み、あなた自身でそれらを探検し、多分多分の呼び出しの間に相違点を見つけることができますか、日付の間の呼び出しの頻度。

142
00:10:41,050 --> 00:10:45,910
たとえば、月や日に基づいて天気が火災にどのような影響を与えるかを調べることは興味深いかもしれません。

143
00:10:45,910 --> 00:10:46,680
&nbsp;

144
00:10:47,110 --> 00:10:49,840
そこに興味深いスパイクがあるのが分かります。

145
00:10:49,840 --> 00:10:50,230
OK。

146
00:10:50,320 --> 00:10:51,550
一緒に移動する。

147
00:10:51,550 --> 00:10:56,140
最後に、Seabornとデータを使ってヒートマップを作成しましょう。

148
00:10:56,410 --> 00:11:01,420
そして、最初に、データフレームを再構成して列が時間になり、インデックスが曜日になるようにする必要があります。

149
00:11:01,480 --> 00:11:04,080
&nbsp;

150
00:11:04,130 --> 00:11:09,940
実際にはこれを行う方法はたくさんありますが、私がお勧めするのは、グループ化されていないメソッドを発見したいという新しい方法でグループを使用することです。

151
00:11:09,970 --> 00:11:13,540
&nbsp;

152
00:11:13,540 --> 00:11:17,470
また、ドキュメンテーションへのリンクがあり、この問題についていれば、ソリューションを参照することができます。

153
00:11:17,470 --> 00:11:18,240
&nbsp;

154
00:11:18,310 --> 00:11:21,820
私に先に進んで、実際にこのようなものを作る方法を打破しましょう。

155
00:11:21,820 --> 00:11:26,400
このヒートマップは、クラスターマップとヒートマップの講義に覚えています。

156
00:11:26,410 --> 00:11:33,280
私たちのデータは、すべての単一セルが列の値とインデックス自体を表す値に変換される行列形式と呼ばれるものになる必要があります。

157
00:11:34,120 --> 00:11:38,440
&nbsp;

158
00:11:38,470 --> 00:11:40,980
金曜日はゼロを意味します。

159
00:11:40,990 --> 00:11:42,820
これは何回の呼び出しが発生したかです。

160
00:11:43,240 --> 00:11:47,300
OKをクリックして、スタックされていないメソッドの使用方法を学習しましょう。

161
00:11:47,310 --> 00:11:50,980
次に、マニュアルにいくつかの例がありますが、あなた自身で発見したかもしれません。

162
00:11:50,980 --> 00:11:51,430
&nbsp;

163
00:11:51,640 --> 00:11:52,560
しかし、彼はそれに立ち往生した。

164
00:11:52,570 --> 00:11:56,310
私はあなたに今すぐそれをする方法を示すつもりだから心配しないでください。

165
00:11:56,440 --> 00:11:59,320
私たちは先に進んで、DFグループで言うつもりです。

166
00:11:59,740 --> 00:12:03,580
そして私はリストでグループ化しなければならないだろう。

167
00:12:03,580 --> 00:12:10,070
&nbsp;

168
00:12:14,470 --> 00:12:21,070
この場合、私は週単位でグループ化するのではなく、時間単位でグループ化したいと思っています。そして、私が先に進もうとしているときに、これを数えてみると、これがどうなっているのか見てみましょうこれは基本的に私がグループ化してマルチレベルのインデックスを作成することを可能にします。

169
00:12:21,070 --> 00:12:25,650
&nbsp;

170
00:12:25,690 --> 00:12:31,330
曜日と時間、次に各列のカウントだけが表示されます。

171
00:12:31,390 --> 00:12:39,250
だから私はこの多段階指数を持っていますが、今私ができることは単なる列を呼び出すだけで、私たちは先に進んでそれを行うことができます。そして、私はこの多段階指数を持っています。

172
00:12:39,310 --> 00:12:40,270
&nbsp;

173
00:12:43,690 --> 00:12:45,960
&nbsp;

174
00:12:46,090 --> 00:12:52,570
そして、スタックされていないメソッドの鍵は、基本的にこれをアンスタックして、これを行列形式にすることです。

175
00:12:52,570 --> 00:12:54,840
&nbsp;

176
00:12:56,410 --> 00:12:58,230
そして今、私はこの行列形式を持っています。

177
00:12:58,240 --> 00:13:04,810
&nbsp;

178
00:13:04,810 --> 00:13:10,870
&nbsp;

179
00:13:10,870 --> 00:13:12,970
つまり、ステップは複数の列でグループ化され、その複数レベルの索引が作成され、その索引を基本的にスタックから取り除いて使用してスタックし、その1つを列として作成し、そのうち1つを索引にすることができました。

180
00:13:12,970 --> 00:13:13,340
大丈夫。

181
00:13:13,420 --> 00:13:17,620
もしあなたがこれに悩まされていたり、これに問題があったりしても心配しないでください。これを行うには、実際には非常に高度な方法です。

182
00:13:17,620 --> 00:13:19,050
&nbsp;

183
00:13:19,060 --> 00:13:23,620
Pandursのようなピボットテーブルやピボットテーブルを使用するなど、試してみる可能性がある他の方法がありますが、これを行うことができればあまり心配しないでください。

184
00:13:23,620 --> 00:13:27,230
&nbsp;

185
00:13:27,270 --> 00:13:32,620
練習の経験が豊富で、ドキュメンテーションの内容を見ることができます。

186
00:13:33,980 --> 00:13:40,000
まあ、このデータフレームの一日の時間を呼んで、私たちがそのデータフレームを持っているので、私はヒートマップを簡単に作成できます。この部分は実際にはかなり簡単です。

187
00:13:40,000 --> 00:13:44,250
&nbsp;

188
00:13:44,320 --> 00:13:50,880
我々は昼と時間を過ぎてSとSのヒートマップを呼び出すだけで、それは本質的にすべてです。

189
00:13:50,890 --> 00:13:57,130
&nbsp;

190
00:13:57,130 --> 00:14:04,240
今度は、色のインジケータとして時間と通話回数を比較し、viridisで地図を渡すことを参照して解決策をよりよく見せようとします。

191
00:14:04,240 --> 00:14:09,370
&nbsp;

192
00:14:09,400 --> 00:14:15,250
そして今、私たちはソリューションの中でやっているのと同じ配色をしています.PielがそのFigureを描き、Figureのサイズを引数として追加すると、Figureを少し大きくすることができます。

193
00:14:16,780 --> 00:14:19,000
そして今我々は基本的に解決策にあったものを持っています。

194
00:14:19,120 --> 00:14:24,810
また、sとsのクラスタマップを使って、このデータフレームを使って非常に同じ方法でクラスタマップを作成することもできます。

195
00:14:24,810 --> 00:14:26,950
&nbsp;

196
00:14:26,950 --> 00:14:34,000
やはりデータフレームを渡すだけで、私たちはSeeマップを作成し、同じクラスタマップを作成しました。

197
00:14:36,850 --> 00:14:39,010
&nbsp;

198
00:14:39,010 --> 00:14:43,990
実際にこの行で実際に何が起こっているのか混乱している場合は、Q＆Aフォーラムに投稿してください。

199
00:14:43,990 --> 00:14:44,770
&nbsp;

200
00:14:44,770 --> 00:14:46,900
そしてもう少し説明して嬉しいです。

201
00:14:46,900 --> 00:14:51,520
しかし、これは先進的なものだと心に留めておきましょう。もしあなたが固執すれば解決策を参照すれば心配する必要はありません。

202
00:14:51,520 --> 00:14:54,480
&nbsp;

203
00:14:54,490 --> 00:14:59,230
&nbsp;

204
00:14:59,320 --> 00:15:03,640
&nbsp;

205
00:15:03,640 --> 00:15:06,120
私たちがやりたいことは、データフレームの同じプロットと操作を繰り返して、月を列として表示します。これは、私たちがやったのと本質的に同じコードなので、ソリューションからコピーして貼り付けます上記。

206
00:15:06,130 --> 00:15:12,730
しかし、この場合は、たとえば時間を言うだけでなく、月を設定して、先に進んで確認してください。

207
00:15:12,730 --> 00:15:13,960
&nbsp;

208
00:15:14,140 --> 00:15:18,900
今では月があり、本質的に同じプロットをもう一度作っています。

209
00:15:19,060 --> 00:15:28,110
そこで、ここでは、曜日の代わりに地図のスクロールを少し下にして呼び出すだけです。

210
00:15:28,120 --> 00:15:29,320
私は1ヶ月を使いたいと思っています。

211
00:15:32,590 --> 00:15:33,290
&nbsp;

212
00:15:33,310 --> 00:15:38,020
このヒートマップと、これからクラスターマップを作成したい場合は、クラスターを呼び出す以外は同じことができます。

213
00:15:38,020 --> 00:15:40,200
&nbsp;

214
00:15:40,900 --> 00:15:42,810
これによりクラスタマップが作成されます。

215
00:15:42,910 --> 00:15:47,890
だから、今私は実際にデータを調べて、週の何曜日が夜に発生するのが最も一般的なのかを見てみましょう。

216
00:15:47,890 --> 00:15:51,160
&nbsp;

217
00:15:51,160 --> 00:15:56,020
&nbsp;

218
00:15:56,020 --> 00:16:01,170
そして、ちょっと見てみると、0時から5時の間に多くの通話が起きているわけではありません。それは本質的に真夜中の朝5時ですからです。

219
00:16:01,180 --> 00:16:02,350
誰もが眠っている。

220
00:16:02,500 --> 00:16:07,090
&nbsp;

221
00:16:07,180 --> 00:16:11,980
ほとんどの犯罪行為や理由や私は交通事故や混乱のような1つの呼び出しはありませんが、このデータセットではそれほど多くの犯罪行為ではありません。

222
00:16:12,010 --> 00:16:14,410
それは主に火災のM-Sと交通の理由です。

223
00:16:14,410 --> 00:16:17,330
これらはすべて、昼間の日中に発生する傾向があります。

224
00:16:17,350 --> 00:16:23,320
興味深いのは、日曜日と土曜日にあまりにも多くの人が発生する傾向がなく、クラスタマップでこれを少しはっきりと見ることができるので、コール量が少ないと思われるクラスタが実際に作成され、時にはクラスターマップにとってうまくいくのは、これを実際に見るために涼しい暖かい色のマッピングのようなものを選ぶことです。

225
00:16:23,320 --> 00:16:27,940
&nbsp;

226
00:16:27,940 --> 00:16:34,450
&nbsp;

227
00:16:34,450 --> 00:16:42,490
&nbsp;

228
00:16:42,760 --> 00:16:46,750
そして、時には、人々が実際にグループ分けをするための配色をもう少し明確にしていることもあります。

229
00:16:46,750 --> 00:16:47,850
&nbsp;

230
00:16:48,220 --> 00:16:53,080
私たちは月曜日と火曜日、そして木曜日と金曜日の8時16分と17時には高い電話をしているようです。

231
00:16:53,080 --> 00:16:55,210
&nbsp;

232
00:16:55,210 --> 00:17:01,270
それで、午前中の土曜日と日曜日の間に、低い通話料金と同様に見える傾向にある夕方に向かってもう少しです。

233
00:17:01,330 --> 00:17:03,700
&nbsp;

234
00:17:03,700 --> 00:17:04,290
OK。

235
00:17:04,570 --> 00:17:09,400
&nbsp;

236
00:17:09,400 --> 00:17:14,410
&nbsp;

237
00:17:14,410 --> 00:17:16,350
そして、私たちは月にこれらの操作を繰り返しました。あなたは夏の月と冬の月を比較することができます。そして、あなたはどのようにフィットしているのかを調べ続けることができます。

238
00:17:16,420 --> 00:17:17,200
あなたが楽しんでいただければ幸いです。

239
00:17:17,200 --> 00:17:18,420
面白いと思っていたら

240
00:17:18,820 --> 00:17:23,650
ここでは、このような複雑な1つのライナーのソリューションを調べなければならない場合は、もう気分は悪くありません。

241
00:17:23,710 --> 00:17:28,480
実際に何が起こっているのかを明確にする必要があれば、いつでもQ＆Aフォーラムに投稿することができます。

242
00:17:28,480 --> 00:17:29,680
&nbsp;

243
00:17:29,680 --> 00:17:30,250
大丈夫。

244
00:17:30,370 --> 00:17:32,780
質問があれば投稿してください。

245
00:17:32,860 --> 00:17:35,320
そして、私は次の講義であなたを見るでしょう。

246
00:17:35,320 --> 00:17:36,100
みんな、ありがとう。

247
00:17:36,100 --> 00:17:37,570
あなたがプロジェクトを楽しんでいたらと思っています。
